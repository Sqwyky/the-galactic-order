/**
 * THE GALACTIC ORDER - Terrain Chunk System (Pioneer-Style Quadtree LOD)
 *
 * Upgraded from single-LOD to a true quadtree that subdivides
 * terrain into chunks at different levels of detail, inspired by
 * Pioneer Space Sim's planetary LOD system.
 *
 * Pioneer's approach (translated to our CA-based terrain):
 * 1. Start with large root chunks covering the entire visible area
 * 2. Chunks NEAR the camera SPLIT into 4 children (higher detail)
 * 3. Chunks FAR from the camera MERGE back (lower detail)
 * 4. Each chunk's heightmap is generated by CA rules via WebWorker
 * 5. Split/merge decisions use a hysteresis band to prevent popping
 *
 * Quadtree structure:
 *   Level 0: 1 chunk covering 512m x 512m (far away)
 *   Level 1: 4 chunks of 256m x 256m
 *   Level 2: 16 chunks of 128m x 128m
 *   Level 3: 64 chunks of 64m x 64m (near camera)
 *   Level 4: 256 chunks of 32m x 32m (right under player — max detail)
 *
 * The key insight from Pioneer: the split distance for each level
 * is proportional to the chunk size, so you always have roughly
 * the same triangle density on screen regardless of distance.
 */

import * as THREE from 'three';
import { hashSeed, seededRandom } from '../generation/hashSeed.js';

// ============================================================
// CONFIGURATION
// ============================================================

export const TERRAIN_CONFIG = {
    // Base chunk size in world units (Level 0 = root)
    chunkWorldSize: 64,

    // Heightmap resolution per chunk
    chunkResolution: 33, // 33 = 32 cells + 1 for stitching

    // View radius in chunks (how far terrain extends around the player)
    viewRadius: 6,

    // Height scale multiplier
    heightScale: 15.0,

    // Water level (0-1 in heightmap space) — 0 = no water, all land
    waterLevel: 0.0,

    // Maximum active chunks (memory budget)
    maxChunks: 250,

    // === Pioneer-style Quadtree LOD ===
    // Maximum quadtree depth (0 = root only, 4 = max detail)
    maxQuadtreeDepth: 4,

    // Split distance multiplier — chunk splits when camera is closer
    // than (chunkSize * splitDistanceMultiplier)
    // Pioneer uses ~2.0; we use 2.5 for smoother transitions
    splitDistanceMultiplier: 2.5,

    // Hysteresis factor — chunk must be this much further to merge back
    // Prevents rapid split/merge oscillation at boundary distances
    mergeHysteresis: 1.3,

    // Root chunk size at level 0 (covers wide area)
    rootChunkSize: 512,

    // LOD bias — shift split distances (< 1 = more detail, > 1 = less)
    lodBias: 1.0,
};

// ============================================================
// NMS-STYLE BIOME COLORS (for terrain vertex coloring)
// ============================================================

const NMS_COLORS = [
    [8, 30, 100],       // 0: Deep Ocean — rich dark blue
    [15, 70, 160],      // 1: Ocean — vivid blue
    [240, 220, 160],    // 2: Beach — warm golden sand
    [245, 190, 70],     // 3: Desert — bold amber/orange
    [190, 210, 50],     // 4: Savanna — warm yellow-green
    [50, 200, 40],      // 5: Grassland — vivid bright green
    [20, 160, 35],      // 6: Forest — rich green
    [10, 100, 25],      // 7: Dense Forest — deep emerald
    [50, 120, 55],      // 8: Swamp — muted teal-green
    [170, 145, 120],    // 9: Mountain — warm sandstone
    [250, 250, 255],    // 10: Snow Peak — bright white
    [210, 235, 255],    // 11: Ice — pale blue-white
];

// ============================================================
// QUADTREE NODE — Pioneer-style split/merge logic
// ============================================================

/**
 * A node in the terrain quadtree. Each node can either be a leaf
 * (has a mesh) or a branch (has 4 children). Pioneer's terrain
 * uses this exact pattern — split when close, merge when far.
 */
export class QuadtreeNode {
    /**
     * @param {number} x - Center X in world units
     * @param {number} z - Center Z in world units
     * @param {number} size - Width/height of this node in world units
     * @param {number} depth - Quadtree depth (0 = root)
     * @param {QuadtreeNode|null} parent - Parent node
     */
    constructor(x, z, size, depth, parent = null) {
        this.x = x;
        this.z = z;
        this.size = size;
        this.depth = depth;
        this.parent = parent;

        // Children (null if leaf)
        this.children = null;

        // Mesh (null if branch)
        this.chunk = null;

        // Split state
        this.isSplit = false;
        this.splitDistance = size * TERRAIN_CONFIG.splitDistanceMultiplier * TERRAIN_CONFIG.lodBias;
        this.mergeDistance = this.splitDistance * TERRAIN_CONFIG.mergeHysteresis;
    }

    /**
     * Determine if this node should split (camera is close enough).
     * Pioneer uses distance-to-center with a size-proportional threshold.
     */
    shouldSplit(camX, camZ) {
        if (this.depth >= TERRAIN_CONFIG.maxQuadtreeDepth) return false;
        const dx = camX - this.x;
        const dz = camZ - this.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        return dist < this.splitDistance;
    }

    /**
     * Determine if this node should merge (camera is far enough).
     * Uses hysteresis to prevent oscillation.
     */
    shouldMerge(camX, camZ) {
        const dx = camX - this.x;
        const dz = camZ - this.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        return dist > this.mergeDistance;
    }

    /**
     * Check if camera is within the visible range for this node.
     */
    isVisible(camX, camZ, viewRadius) {
        const halfSize = this.size / 2;
        const maxDist = viewRadius + halfSize;
        const dx = Math.abs(camX - this.x);
        const dz = Math.abs(camZ - this.z);
        return dx < maxDist && dz < maxDist;
    }
}

// ============================================================
// TERRAIN CHUNK (single piece of terrain)
// ============================================================

export class TerrainChunkMesh {
    /**
     * @param {number} x - Chunk X in grid coordinates
     * @param {number} y - Chunk Y in grid coordinates
     * @param {number} depth - Quadtree depth (0 = root, max = most detailed)
     * @param {number} worldSize - Size of this chunk in world units
     */
    constructor(x, y, depth, worldSize) {
        this.x = x;
        this.y = y;
        this.depth = depth;
        this.worldSize = worldSize;
        this.key = `${depth}:${x}:${y}`;

        // State
        this.state = 'pending'; // pending | generating | ready | disposed
        this.mesh = null;
        this.geometry = null;
        this.material = null;

        // Data (filled by worker)
        this.elevation = null;
        this.moisture = null;
        this.biomeIds = null;

        // World position (center of chunk)
        this.worldX = x * worldSize;
        this.worldZ = y * worldSize;

        // LOD metrics
        this.lastDistanceToCamera = Infinity;
    }

    /**
     * Build the 3D mesh from heightmap data.
     * Called after the WebWorker returns the chunk data.
     */
    buildMesh(chunkData, config) {

        this.elevation = chunkData.elevation;
        this.moisture = chunkData.moisture;
        this.biomeIds = chunkData.biomeIds;

        // Data is now (res x res) = (33 x 33) — exactly matching PlaneGeometry vertex count.
        const dataRes = chunkData.chunkSize; // 33

        // Create plane geometry: 32 segments = 33 verts per edge
        const geo = new THREE.PlaneGeometry(
            this.worldSize,
            this.worldSize,
            dataRes - 1,
            dataRes - 1
        );
        geo.rotateX(-Math.PI / 2); // Make it horizontal

        const pos = geo.getAttribute('position');
        const vertCount = pos.count;
        const colors = new Float32Array(vertCount * 3);

        // PlaneGeometry lays out vertices row-by-row matching our data grid.
        // Direct 1:1 mapping — each vertex i maps to data[i].
        for (let i = 0; i < vertCount; i++) {
            const vx = pos.getX(i);
            const vz = pos.getZ(i);
            const elevation = this.elevation[i] || 0;

            // Height displacement — smooth power curve for NMS-style terrain
            let height = 0;
            const wl = config.waterLevel;
            if (elevation > wl + 0.05) {
                // Above water: smooth power curve
                const normalizedElev = (elevation - wl) / (1.0 - wl);
                height = Math.pow(normalizedElev, 1.4) * config.heightScale;
                // Gentle extra lift for high peaks
                if (elevation > 0.75) {
                    height += (elevation - 0.75) * config.heightScale * 0.6;
                }
            } else if (elevation > wl - 0.05) {
                // Beach/shoreline transition zone — smooth blend from water to land
                const t = (elevation - (wl - 0.05)) / 0.10; // 0-1 across transition
                const smoothT = t * t * (3 - 2 * t); // Hermite smoothstep
                height = smoothT * 0.3; // Gentle beach slope (0 to 0.3m)
            } else {
                // Below water: gentle ocean floor
                const depth = (wl - elevation) / wl;
                height = -0.3 - depth * 0.5; // -0.3 to -0.8m
            }

            pos.setY(i, height);

            // Biome color
            const biomeId = this.biomeIds[i] || 0;

            if (elevation <= config.waterLevel) {
                const depth = 1.0 - (elevation / Math.max(config.waterLevel, 0.001));
                colors[i * 3] = (10 + depth * 5) / 255;
                colors[i * 3 + 1] = (30 + depth * 15) / 255;
                colors[i * 3 + 2] = (80 + depth * 40) / 255;
            } else {
                const col = NMS_COLORS[biomeId] || [255, 0, 255];

                // Elevation-based brightness: lower = darker (fake AO in valleys)
                const elevFactor = 0.7 + elevation * 0.3;

                // Multi-octave color variation for NMS-style painterly terrain
                const wx = this.worldX + vx;
                const wz = this.worldZ + vz;

                // Low frequency: broad color patches
                const seed1 = hashSeed(Math.round(wx * 0.15), Math.round(wz * 0.15));
                const lo = ((seed1 & 0xFF) / 255 - 0.5) * 0.12;

                // Mid frequency: smaller splotches
                const seed2 = hashSeed(Math.round(wx * 0.5), Math.round(wz * 0.5));
                const mid = ((seed2 & 0xFF) / 255 - 0.5) * 0.08;

                // High frequency: micro detail
                const seed3 = hashSeed(Math.round(wx * 1.5), Math.round(wz * 1.5));
                const hi = ((seed3 & 0xFF) / 255 - 0.5) * 0.04;

                const variation = lo + mid + hi;

                // Slope darkening — steeper terrain gets darker (fake AO)
                const slopeDarken = (i > 0 && i < this.elevation.length - 1) ?
                    Math.abs(this.elevation[i] - this.elevation[Math.max(0, i - 1)]) * 2.0 : 0;
                const slopeFactor = Math.max(0.7, 1.0 - slopeDarken);

                // Per-channel color variation (slightly different per channel for richness)
                const seed4 = hashSeed(Math.round(wx * 0.8), Math.round(wz * 0.3));
                const rShift = ((seed4 & 0xFF) / 255 - 0.5) * 0.03;
                const gShift = (((seed4 >> 8) & 0xFF) / 255 - 0.5) * 0.03;

                const r = (col[0] / 255) * elevFactor * slopeFactor + variation + rShift;
                const g = (col[1] / 255) * elevFactor * slopeFactor + variation + gShift;
                const b = (col[2] / 255) * elevFactor * slopeFactor + variation;

                colors[i * 3] = Math.max(0, Math.min(1, r));
                colors[i * 3 + 1] = Math.max(0, Math.min(1, g));
                colors[i * 3 + 2] = Math.max(0, Math.min(1, b));
            }
        }

        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geo.computeVertexNormals();

        // MeshStandardMaterial with PBR for shadow receiving and depth
        const mat = new THREE.MeshStandardMaterial({
            vertexColors: true,
            flatShading: false,
            roughness: 0.85,
            metalness: 0.02,
        });

        this.geometry = geo;
        this.material = mat;
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.set(this.worldX, 0, this.worldZ);

        // Terrain receives shadows from sun (flora/rocks cast)
        this.mesh.castShadow = false;
        this.mesh.receiveShadow = true;

        this.state = 'ready';
        return this.mesh;
    }

    /**
     * Get the height at a specific world position (for physics/walking).
     * Uses bilinear interpolation of the elevation data for smooth results.
     */
    getHeightAt(worldX, worldZ) {
        if (!this.elevation) return 0;

        const localX = worldX - (this.worldX - this.worldSize / 2);
        const localZ = worldZ - (this.worldZ - this.worldSize / 2);
        const u = localX / this.worldSize;
        const v = localZ / this.worldSize;

        if (u < 0 || u > 1 || v < 0 || v > 1) return null;

        const dataRes = Math.round(Math.sqrt(this.elevation.length));
        const gx = Math.min(Math.floor(u * (dataRes - 1)), dataRes - 2);
        const gy = Math.min(Math.floor(v * (dataRes - 1)), dataRes - 2);
        const fx = u * (dataRes - 1) - gx;
        const fy = v * (dataRes - 1) - gy;

        const e00 = this.elevation[gy * dataRes + gx] || 0;
        const e10 = this.elevation[gy * dataRes + gx + 1] || 0;
        const e01 = this.elevation[(gy + 1) * dataRes + gx] || 0;
        const e11 = this.elevation[(gy + 1) * dataRes + gx + 1] || 0;
        const elevation = e00 * (1 - fx) * (1 - fy) + e10 * fx * (1 - fy) +
                         e01 * (1 - fx) * fy + e11 * fx * fy;

        // Same height formula as buildMesh
        const wl = TERRAIN_CONFIG.waterLevel;
        let height = 0;
        if (elevation > wl + 0.05) {
            const normalizedElev = (elevation - wl) / (1.0 - wl);
            height = Math.pow(normalizedElev, 1.4) * TERRAIN_CONFIG.heightScale;
            if (elevation > 0.75) {
                height += (elevation - 0.75) * TERRAIN_CONFIG.heightScale * 0.6;
            }
        } else if (elevation > wl - 0.05) {
            const t = (elevation - (wl - 0.05)) / 0.10;
            const smoothT = t * t * (3 - 2 * t);
            height = smoothT * 0.3;
        } else {
            const depth = (wl - elevation) / wl;
            height = -0.3 - depth * 0.5;
        }
        return height;
    }

    dispose() {
        if (this.geometry) this.geometry.dispose();
        if (this.material) this.material.dispose();
        this.mesh = null;
        this.state = 'disposed';
    }
}

// ============================================================
// TERRAIN MANAGER — Pioneer-style quadtree + worker orchestration
// ============================================================

export class TerrainManager {
    /**
     * @param {THREE.Scene} scene
     * @param {Object} planetData - { rule, seed, moistureRule }
     * @param {Object} [config] - Override TERRAIN_CONFIG
     */
    constructor(scene, planetData, config = {}) {
        this.scene = scene;
        this.planetData = planetData;
        this.config = { ...TERRAIN_CONFIG, ...config };

        // Active chunks (key -> TerrainChunkMesh)
        this.chunks = new Map();

        // Chunks being generated
        this.pendingChunks = new Map();

        // Web Worker (cache-bust to ensure latest version loads)
        this.worker = new Worker('./js/terrain/TerrainWorker.js?v=' + Date.now());
        this.worker.onmessage = (e) => this._onWorkerMessage(e);

        // Generation queue (priority queue by distance to camera)
        this.generationQueue = [];
        this.isGenerating = false;

        // Quadtree roots — grid of root-level nodes
        this.quadtreeRoots = new Map();

        // Water plane
        this.waterMesh = null;

        // Stats
        this.stats = {
            activeChunks: 0,
            pendingChunks: 0,
            totalTriangles: 0,
            maxDepth: 0,
        };
    }

    /**
     * Update terrain based on camera position.
     * Uses Pioneer-style quadtree: split close chunks, merge far ones.
     */
    update(cameraPosition) {
        const camX = cameraPosition.x;
        const camZ = cameraPosition.z;

        // Determine which chunks should exist via quadtree evaluation
        const desiredChunks = this._getDesiredChunks(camX, camZ);

        // Find new chunks to generate
        for (const [key, chunkInfo] of desiredChunks) {
            if (!this.chunks.has(key) && !this.pendingChunks.has(key)) {
                this._requestChunk(chunkInfo);
            }
        }

        // Remove chunks that are no longer needed
        for (const [key, chunk] of this.chunks) {
            if (!desiredChunks.has(key)) {
                this._removeChunk(key);
            }
        }

        // Process generation queue
        this._processQueue();

        // Update water plane position
        if (this.waterMesh) {
            this.waterMesh.position.set(camX, -0.3, camZ);
        }

        // Update stats
        this.stats.activeChunks = this.chunks.size;
        this.stats.pendingChunks = this.pendingChunks.size;
    }

    /**
     * Pioneer-style quadtree chunk selection.
     *
     * For each potential root chunk in view range, recursively decide:
     * - If camera is close enough → SPLIT into 4 children
     * - If camera is far enough → this chunk is a LEAF (render it)
     *
     * This gives us high detail nearby and coarse detail far away,
     * exactly like Pioneer's planetary terrain.
     */
    _getDesiredChunks(camX, camZ) {
        const desired = new Map();
        const chunkSize = this.config.chunkWorldSize;
        const radius = this.config.viewRadius || 8;

        // Camera position in chunk grid coordinates
        const gridCamX = Math.floor(camX / chunkSize);
        const gridCamZ = Math.floor(camZ / chunkSize);

        for (let dx = -radius; dx <= radius; dx++) {
            for (let dz = -radius; dz <= radius; dz++) {
                // Circular view distance (not square)
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist > radius) continue;

                const cx = gridCamX + dx;
                const cz = gridCamZ + dz;

                // Evaluate quadtree for this root chunk
                this._evaluateQuadtreeNode(
                    cx * chunkSize, // world center X
                    cz * chunkSize, // world center Z
                    chunkSize,      // size at this level
                    0,              // depth
                    cx, cz,         // grid coords
                    camX, camZ,     // camera position
                    desired
                );
            }
        }

        return desired;
    }

    /**
     * Recursively evaluate a quadtree node.
     * If close enough to camera and not at max depth, split into 4 children.
     * Otherwise, add this node as a leaf chunk to render.
     */
    _evaluateQuadtreeNode(worldX, worldZ, size, depth, gridX, gridZ, camX, camZ, desired) {
        // Distance from camera to chunk center
        const dx = camX - worldX;
        const dz = camZ - worldZ;
        const dist = Math.sqrt(dx * dx + dz * dz);

        // Pioneer's split criterion: split if camera is within (size * multiplier)
        const splitDist = size * this.config.splitDistanceMultiplier * this.config.lodBias;
        const shouldSplit = depth < this.config.maxQuadtreeDepth && dist < splitDist;

        if (shouldSplit) {
            // Split into 4 children
            const halfSize = size / 2;
            const quarterSize = size / 4;
            const childDepth = depth + 1;

            // NW, NE, SW, SE children
            const offsets = [
                [-quarterSize, -quarterSize],
                [+quarterSize, -quarterSize],
                [-quarterSize, +quarterSize],
                [+quarterSize, +quarterSize],
            ];

            for (let i = 0; i < 4; i++) {
                const childX = worldX + offsets[i][0];
                const childZ = worldZ + offsets[i][1];
                // Child grid coords encode both parent position and quadrant
                const childGridX = gridX * 2 + (i & 1);
                const childGridZ = gridZ * 2 + ((i >> 1) & 1);

                this._evaluateQuadtreeNode(
                    childX, childZ,
                    halfSize, childDepth,
                    childGridX, childGridZ,
                    camX, camZ,
                    desired
                );
            }
        } else {
            // This is a leaf — render it
            const key = `${depth}:${gridX}:${gridZ}`;
            desired.set(key, {
                x: gridX,
                y: gridZ,
                depth,
                worldSize: size,
                worldX,
                worldZ,
                distance: dist,
            });

            // Track max depth for stats
            if (depth > this.stats.maxDepth) {
                this.stats.maxDepth = depth;
            }
        }
    }

    /**
     * Queue a chunk for generation by the WebWorker.
     */
    _requestChunk(chunkInfo) {
        const { x, y, depth, worldSize, worldX, worldZ, distance } = chunkInfo;
        const key = `${depth}:${x}:${y}`;

        const chunk = new TerrainChunkMesh(x, y, depth, worldSize);
        // Override world position for quadtree children
        if (worldX !== undefined) {
            chunk.worldX = worldX;
            chunk.worldZ = worldZ;
        }
        chunk.state = 'queued';
        this.pendingChunks.set(key, chunk);

        this.generationQueue.push({
            key,
            chunk,
            distance,
            params: {
                type: 'generateChunk',
                chunkX: x,
                chunkY: y,
                chunkSize: this.config.chunkResolution - 1,
                rule: this.planetData.rule,
                seed: this.planetData.seed,
                moistureRule: this.planetData.moistureRule || ((this.planetData.rule + 73) & 0xFF),
                // Pass LOD depth so worker can adjust generation
                lodDepth: depth,
                worldSize: worldSize,
            }
        });

        // Sort by distance (closest first)
        this.generationQueue.sort((a, b) => a.distance - b.distance);
    }

    /**
     * Process the generation queue — send one chunk at a time to the worker.
     */
    _processQueue() {
        if (this.isGenerating || this.generationQueue.length === 0) return;

        // Pop highest priority
        const job = this.generationQueue.shift();
        if (!job) return;

        // Check if still needed
        if (job.chunk.state === 'disposed') {
            this._processQueue(); // Try next
            return;
        }

        this.isGenerating = true;
        job.chunk.state = 'generating';
        this.worker.postMessage(job.params);
    }

    /**
     * Handle completed chunk from WebWorker.
     */
    _onWorkerMessage(e) {
        const data = e.data;
        if (data.type !== 'chunkReady') return;

        this.isGenerating = false;

        // Find the pending chunk
        let matchKey = null;
        for (const [key, chunk] of this.pendingChunks) {
            if (chunk.x === data.chunkX && chunk.y === data.chunkY && chunk.state === 'generating') {
                matchKey = key;
                break;
            }
        }

        if (!matchKey) {
            // Chunk was removed while generating — discard
            this._processQueue();
            return;
        }

        const chunk = this.pendingChunks.get(matchKey);
        this.pendingChunks.delete(matchKey);

        // Build the 3D mesh
        const mesh = chunk.buildMesh(data, this.config);
        if (mesh) {
            this.scene.add(mesh);
            this.chunks.set(matchKey, chunk);
        }

        // Continue processing queue
        this._processQueue();
    }

    /**
     * Remove a chunk from the scene.
     */
    _removeChunk(key) {
        const chunk = this.chunks.get(key);
        if (chunk) {
            if (chunk.mesh) this.scene.remove(chunk.mesh);
            chunk.dispose();
            this.chunks.delete(key);
        }

        // Also remove from pending if still waiting
        const pending = this.pendingChunks.get(key);
        if (pending) {
            pending.state = 'disposed';
            this.pendingChunks.delete(key);
        }
    }

    /**
     * Create the water plane with animated wave shader.
     * NMS-style: semi-transparent, subtle waves, Fresnel reflections.
     * @param {THREE.Color} [fogColor] - Fog color for blending
     * @param {THREE.Vector3} [sunDirection] - Sun direction for specular
     */
    createWater(fogColor, sunDirection) {
        const size = this.config.chunkWorldSize * 20; // Large enough to cover view
        const segments = 64; // Enough for visible wave displacement
        const geo = new THREE.PlaneGeometry(size, size, segments, segments);
        geo.rotateX(-Math.PI / 2);

        const mat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0.0 },
                uWaterColor: { value: new THREE.Color(0x0a3060) },
                uDeepColor: { value: new THREE.Color(0x020c1f) },
                uFogColor: { value: fogColor || new THREE.Color(0x88aacc) },
                uFogDensity: { value: 0.0025 },
                uSunDirection: { value: sunDirection || new THREE.Vector3(0.5, 0.3, 0.4).normalize() },
                uSunColor: { value: new THREE.Color(0xffeedd) },
                uCameraPos: { value: new THREE.Vector3() },
            },
            vertexShader: /* glsl */ `
                uniform float uTime;
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying float vFogDepth;

                void main() {
                    vec3 pos = position;

                    // Layered sine waves for organic water motion
                    float wave1 = sin(pos.x * 0.08 + uTime * 0.8) * 0.15;
                    float wave2 = sin(pos.z * 0.06 + uTime * 0.6 + 1.0) * 0.12;
                    float wave3 = sin((pos.x + pos.z) * 0.12 + uTime * 1.2) * 0.08;
                    float wave4 = sin(pos.x * 0.25 + pos.z * 0.18 + uTime * 1.5) * 0.04;
                    pos.y += wave1 + wave2 + wave3 + wave4;

                    // Compute normal from wave derivatives
                    float dx = cos(pos.x * 0.08 + uTime * 0.8) * 0.08 * 0.15
                             + cos((pos.x + pos.z) * 0.12 + uTime * 1.2) * 0.12 * 0.08
                             + cos(pos.x * 0.25 + pos.z * 0.18 + uTime * 1.5) * 0.25 * 0.04;
                    float dz = cos(pos.z * 0.06 + uTime * 0.6 + 1.0) * 0.06 * 0.12
                             + cos((pos.x + pos.z) * 0.12 + uTime * 1.2) * 0.12 * 0.08
                             + cos(pos.x * 0.25 + pos.z * 0.18 + uTime * 1.5) * 0.18 * 0.04;

                    vNormal = normalize(vec3(-dx, 1.0, -dz));

                    vec4 worldPos = modelMatrix * vec4(pos, 1.0);
                    vWorldPosition = worldPos.xyz;

                    vec4 mvPosition = viewMatrix * worldPos;
                    vFogDepth = length(mvPosition.xyz);

                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: /* glsl */ `
                uniform vec3 uWaterColor;
                uniform vec3 uDeepColor;
                uniform vec3 uFogColor;
                uniform float uFogDensity;
                uniform vec3 uSunDirection;
                uniform vec3 uSunColor;
                uniform vec3 uCameraPos;
                uniform float uTime;

                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying float vFogDepth;

                // ---- Procedural noise for shore foam ----
                float hash(vec2 p) {
                    float h = dot(p, vec2(127.1, 311.7));
                    return fract(sin(h) * 43758.5453123);
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                }

                float fbm(vec2 p) {
                    float v = 0.0;
                    float a = 0.5;
                    for (int i = 0; i < 4; i++) {
                        v += a * noise(p);
                        p *= 2.0;
                        a *= 0.5;
                    }
                    return v;
                }
                // ---- End noise ----

                void main() {
                    vec3 viewDir = normalize(uCameraPos - vWorldPosition);
                    vec3 normal = normalize(vNormal);

                    // Fresnel effect — more reflective at shallow angles
                    float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);
                    fresnel = 0.3 + 0.7 * fresnel;

                    // Depth-based coloring
                    float distFromCenter = length(vWorldPosition.xz - uCameraPos.xz);
                    vec3 shallowColor = vec3(0.1, 0.45, 0.5);
                    float shallowFactor = smoothstep(80.0, 10.0, distFromCenter) * 0.4;
                    vec3 baseWater = mix(uWaterColor, shallowColor, shallowFactor);

                    vec3 waterCol = mix(uDeepColor, baseWater, fresnel);

                    // Specular highlight from sun
                    vec3 halfDir = normalize(uSunDirection + viewDir);
                    float spec = pow(max(dot(normal, halfDir), 0.0), 128.0);
                    vec3 specular = uSunColor * spec * 0.8;

                    // Broad sun reflection
                    float broadSpec = pow(max(dot(normal, halfDir), 0.0), 8.0);
                    vec3 broadReflection = uSunColor * broadSpec * 0.15;

                    // Ripple highlights
                    float ripple = sin(vWorldPosition.x * 0.5 + vWorldPosition.z * 0.3 + uTime * 2.0);
                    float rippleHighlight = smoothstep(0.85, 1.0, ripple) * 0.1;

                    // Shore foam
                    vec2 foamUV = vWorldPosition.xz * 0.15;
                    float foamNoise = fbm(foamUV + uTime * vec2(0.05, 0.03));
                    float foamNoise2 = fbm(foamUV * 2.5 + uTime * vec2(-0.03, 0.07) + 50.0);

                    float waveHeight = normal.y;
                    float crestFoam = smoothstep(0.92, 0.98, waveHeight) * foamNoise * 0.6;
                    float shoreFoam = shallowFactor * smoothstep(0.4, 0.7, foamNoise2) * 0.5;
                    float totalFoam = max(crestFoam, shoreFoam);
                    vec3 foamColor = vec3(0.9, 0.95, 1.0);
                    waterCol = mix(waterCol, foamColor, totalFoam);

                    vec3 color = waterCol + specular + broadReflection;
                    color += vec3(rippleHighlight);

                    // Fog
                    float fogFactor = 1.0 - exp(-uFogDensity * uFogDensity * vFogDepth * vFogDepth);
                    fogFactor = clamp(fogFactor, 0.0, 1.0);
                    color = mix(color, uFogColor, fogFactor);

                    float distFade = smoothstep(500.0, 300.0, vFogDepth);

                    gl_FragColor = vec4(color, 0.85 * distFade);
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            fog: false,
        });

        this.waterMesh = new THREE.Mesh(geo, mat);
        this.waterMesh.position.y = -0.1;
        this.waterMaterial = mat;
        this.scene.add(this.waterMesh);

        return this.waterMesh;
    }

    /**
     * Update water uniforms (call each frame).
     */
    updateWater(time, cameraPosition) {
        if (!this.waterMaterial) return;
        this.waterMaterial.uniforms.uTime.value = time;
        if (cameraPosition) {
            this.waterMaterial.uniforms.uCameraPos.value.copy(cameraPosition);
            if (this.waterMesh) {
                this.waterMesh.position.x = cameraPosition.x;
                this.waterMesh.position.z = cameraPosition.z;
            }
        }
    }

    /**
     * Get terrain height at a world position.
     * Queries the chunk that contains this position.
     */
    getHeightAt(worldX, worldZ) {
        for (const [key, chunk] of this.chunks) {
            if (chunk.state !== 'ready') continue;

            const halfSize = chunk.worldSize / 2;
            if (worldX >= chunk.worldX - halfSize && worldX < chunk.worldX + halfSize &&
                worldZ >= chunk.worldZ - halfSize && worldZ < chunk.worldZ + halfSize) {
                return chunk.getHeightAt(worldX, worldZ);
            }
        }
        return null;
    }

    /**
     * Get stats for HUD display.
     */
    getStats() {
        let totalTris = 0;
        for (const chunk of this.chunks.values()) {
            if (chunk.mesh && chunk.geometry) {
                const idx = chunk.geometry.index;
                totalTris += idx ? idx.count / 3 : chunk.geometry.getAttribute('position').count / 3;
            }
        }
        this.stats.totalTriangles = totalTris;
        return this.stats;
    }

    /**
     * Dispose everything.
     */
    dispose() {
        for (const chunk of this.chunks.values()) {
            if (chunk.mesh) this.scene.remove(chunk.mesh);
            chunk.dispose();
        }
        this.chunks.clear();
        this.pendingChunks.clear();
        this.generationQueue = [];

        if (this.waterMesh) {
            this.scene.remove(this.waterMesh);
            this.waterMesh.geometry.dispose();
            this.waterMesh.material.dispose();
        }

        this.worker.terminate();
    }
}
