<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Galactic Order - Planetary Landing</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        #game-canvas { display: block; width: 100vw; height: 100vh; }

        /* Atmosphere overlay — gets more opaque as we descend */
        #atmos-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* Vignette — now handled by GPU post-processing shader */
        /* CSS overlay removed to avoid double-vignette */

        /* HUD */
        #hud {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        /* Planet name banner */
        #planet-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: opacity 1.5s;
        }
        #planet-banner.visible { opacity: 1; }
        #planet-banner h1 {
            color: #fff;
            font-size: 36px;
            letter-spacing: 12px;
            text-shadow: 0 0 30px rgba(0,200,255,0.3);
            font-weight: 300;
        }
        #planet-banner .subtitle {
            color: #556;
            font-size: 12px;
            letter-spacing: 4px;
            margin-top: 8px;
        }

        /* Altitude HUD */
        #altitude-hud {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        #altitude-hud .altitude {
            color: #00ff88;
            font-size: 24px;
            letter-spacing: 3px;
        }
        #altitude-hud .label {
            color: #445;
            font-size: 10px;
            letter-spacing: 2px;
            margin-top: 4px;
        }

        /* Status bar */
        #status-bar {
            position: absolute;
            top: 16px;
            left: 16px;
        }
        #status-bar .phase {
            color: #00ff88;
            font-size: 12px;
            letter-spacing: 3px;
        }
        #status-bar .info {
            color: #334;
            font-size: 10px;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        /* Controls hint */
        #controls-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0;
            transition: opacity 1s;
        }
        #controls-hint.visible { opacity: 1; }
        #controls-hint .key {
            display: inline-block;
            border: 1px solid rgba(0,255,136,0.3);
            color: #00ff88;
            padding: 3px 8px;
            font-size: 10px;
            margin: 0 2px;
            letter-spacing: 1px;
        }
        #controls-hint .desc {
            color: #445;
            font-size: 10px;
            margin-top: 6px;
        }

        /* Perf */
        #perf {
            position: absolute;
            top: 16px;
            right: 16px;
            color: #333;
            font-size: 10px;
            text-align: right;
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 20px; height: 20px;
            pointer-events: none;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #crosshair.visible { opacity: 0.5; }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
        }
        #crosshair::before {
            width: 1px; height: 100%;
            left: 50%; top: 0;
        }
        #crosshair::after {
            width: 100%; height: 1px;
            top: 50%; left: 0;
        }

        /* Loading */
        #loading {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 2s;
        }
        #loading.fade { opacity: 0; pointer-events: none; }
        #loading h2 {
            color: #00ff88;
            font-size: 14px;
            letter-spacing: 6px;
        }
        #loading .bar { width: 300px; height: 2px; background: #111; margin-top: 20px; }
        #loading .bar-fill { height: 100%; background: #00ff88; width: 0%; transition: width 0.3s; }
        #loading .status { color: #444; font-size: 11px; margin-top: 12px; }

        /* Scan lines removed — was adding fuzzy pixel noise */
    </style>
</head>
<body>

<canvas id="game-canvas"></canvas>
<!-- vignette moved to GPU post-processing -->
<!-- scanlines removed -->
<div id="atmos-overlay"></div>
<div id="crosshair"></div>

<div id="hud">
    <div id="planet-banner">
        <h1 id="bannerName">PLANET</h1>
        <div class="subtitle" id="bannerSubtitle"></div>
    </div>

    <div id="altitude-hud">
        <div class="altitude" id="altitudeValue">---</div>
        <div class="label">ALTITUDE</div>
    </div>

    <div id="status-bar">
        <div class="phase" id="phaseName">ATMOSPHERIC ENTRY</div>
        <div class="info" id="phaseInfo"></div>
    </div>

    <div id="controls-hint">
        <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span>
        <span class="key">SHIFT</span>
        <span class="key">SPACE</span>
        <span class="key">E</span>
        <div class="desc">MOVE · SPRINT · JUMP · BOARD SHIP — CLICK TO MINE/LOOK</div>
    </div>

    <div id="perf"></div>
</div>

<div id="loading">
    <h2>ATMOSPHERIC ENTRY</h2>
    <div class="bar"><div class="bar-fill" id="loadingBar"></div></div>
    <div class="status" id="loadingStatus">Calculating descent vector...</div>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { TerrainManager, TERRAIN_CONFIG } from './js/terrain/TerrainChunk.js';
import { WalkingController } from './js/terrain/WalkingController.js';
import { hashSeed } from './js/generation/hashSeed.js';
import { classifyRule } from './js/generation/cellularAutomata.js';
import { generatePlanetName } from './js/generation/nameGenerator.js';
import { NPCManager } from './js/npc/NPCManager.js';
import { DialogueSystem } from './js/ui/DialogueSystem.js';
import { TabletUI } from './js/ui/TabletUI.js';
import { SkyDome } from './js/rendering/SkyDome.js';
import { GrassSystem } from './js/terrain/GrassSystem.js';
import { RockScatter } from './js/terrain/RockScatter.js';
import { AtmosphericParticles } from './js/rendering/AtmosphericParticles.js';
import { AlienFloraSystem } from './js/terrain/AlienFlora.js';
import { derivePlanetMood, derivePlanetFrequency, frequencyToNote } from './js/generation/harmonicResonance.js';

// Ship systems
import { ShipModel } from './js/ship/ShipModel.js';
import { FlightController } from './js/ship/FlightController.js';
import { WeaponSystem } from './js/ship/WeaponSystem.js';
import { ScannerSystem } from './js/ship/ScannerSystem.js';
import { HyperspaceSystem } from './js/ship/HyperspaceSystem.js';
import { ShipHUD } from './js/ui/ShipHUD.js';

// Mining & Crafting systems
import { MiningSystem } from './js/terrain/MiningSystem.js';
import { InventoryManager } from './js/ui/InventoryManager.js';
import { MiningHUD } from './js/ui/MiningHUD.js';
import { ELEMENTS } from './js/generation/HarmonicElements.js';
import { PerformanceManager } from './js/rendering/PerformanceManager.js';

// Post-processing imports
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';

// ============================================================
// URL PARAMS — planet identity
// ============================================================
const params = new URLSearchParams(window.location.search);
let planetRule = parseInt(params.get('rule')) || 30;
let planetSeed = parseInt(params.get('seed')) || 42;
let planetName = params.get('name') || generatePlanetName(hashSeed(planetSeed, 'planet', 0));

// ============================================================
// LOADING
// ============================================================
const loadingEl = document.getElementById('loading');
const loadingBar = document.getElementById('loadingBar');
const loadingStatus = document.getElementById('loadingStatus');
function setLoading(pct, msg) {
    loadingBar.style.width = pct + '%';
    loadingStatus.textContent = msg;
}

// ============================================================
// LANDING PHASES
// ============================================================
const PHASE = {
    DESCENT: 'descent',   // Flying down through atmosphere
    LANDING: 'landing',   // Final approach to ground
    SURFACE: 'surface',   // Walking on the surface
    FLIGHT: 'flight',     // Flying ship
};
let currentPhase = PHASE.DESCENT;

// ============================================================
// RENDERER
// ============================================================
setLoading(10, 'Creating renderer...');
const canvas = document.getElementById('game-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
// Soft shadow maps — controlled by performance tier (disabled on LOW/POTATO)
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

// ============================================================
// POST-PROCESSING — the NMS "cinematic painted sci-fi" look
// ============================================================
const composer = new EffectComposer(renderer);

// Color Grading shader — cinematic NMS look: S-curve contrast, split toning,
// chromatic aberration, vignette, subtle warm/cool shift
const colorGradeShader = {
    uniforms: {
        tDiffuse: { value: null },
        uSaturation: { value: 1.3 },
        uContrast: { value: 1.12 },
        uBrightness: { value: 0.01 },
        uVignetteStrength: { value: 0.45 },
        uChromaticAberration: { value: 0.003 },
    },
    vertexShader: /* glsl */ `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */ `
        uniform sampler2D tDiffuse;
        uniform float uSaturation;
        uniform float uContrast;
        uniform float uBrightness;
        uniform float uVignetteStrength;
        uniform float uChromaticAberration;
        varying vec2 vUv;

        // Filmic S-curve tone map (more cinematic than linear contrast)
        vec3 sCurve(vec3 x) {
            return x * x * (3.0 - 2.0 * x);
        }

        void main() {
            // Radial chromatic aberration — stronger at screen edges
            vec2 center = vUv - 0.5;
            float edgeDist = length(center);
            vec2 dir = center * uChromaticAberration * (1.0 + edgeDist * 2.0);
            float r = texture2D(tDiffuse, vUv + dir).r;
            float g = texture2D(tDiffuse, vUv).g;
            float b = texture2D(tDiffuse, vUv - dir).b;
            vec3 color = vec3(r, g, b);

            // Saturation boost (NMS vivid palette)
            float luma = dot(color, vec3(0.299, 0.587, 0.114));
            color = mix(vec3(luma), color, uSaturation);

            // S-curve contrast (smooth, filmic — lifts shadows, compresses highlights)
            color = clamp(color, 0.0, 1.0);
            color = mix(color, sCurve(color), uContrast - 1.0 + 0.4);
            color += uBrightness;

            // Split toning — warm highlights (gold), cool shadows (blue)
            vec3 warmTint  = vec3(1.02, 0.98, 0.92);  // Subtle gold
            vec3 coolTint  = vec3(0.92, 0.95, 1.05);  // Subtle blue
            float lumaSplit = dot(color, vec3(0.299, 0.587, 0.114));
            vec3 tint = mix(coolTint, warmTint, smoothstep(0.25, 0.75, lumaSplit));
            color *= tint;

            // Vignette — smooth elliptical falloff, cinematic
            float vigDist = length(center * vec2(1.1, 1.0));
            float vig = smoothstep(0.3, 1.1, vigDist) * uVignetteStrength;
            vig += smoothstep(0.6, 1.3, vigDist) * uVignetteStrength * 0.3; // Extra darkening at corners
            color *= 1.0 - vig;

            gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
        }
    `
};

// Film Grain shader — dual-frequency grain for photographic 70s sci-fi texture
const filmGrainShader = {
    uniforms: {
        tDiffuse: { value: null },
        uTime: { value: 0.0 },
        uIntensity: { value: 0.025 },
    },
    vertexShader: /* glsl */ `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */ `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uIntensity;
        varying vec2 vUv;

        float hash(vec2 p) {
            float h = dot(p, vec2(127.1, 311.7));
            return fract(sin(h) * 43758.5453123);
        }
        float hash2(vec2 p) {
            float h = dot(p, vec2(269.5, 183.3));
            return fract(sin(h) * 28786.3157832);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            // Dual-frequency grain — fine + coarse for photographic feel
            float fineGrain  = hash(vUv * 1200.0 + uTime * 137.0) * 2.0 - 1.0;
            float coarseGrain = hash2(vUv * 300.0 + uTime * 89.0) * 2.0 - 1.0;
            float grain = fineGrain * 0.7 + coarseGrain * 0.3;

            // Grain is stronger in shadows (real film response)
            float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114));
            float grainStrength = uIntensity * (1.2 - luma * 0.6);

            // Subtle color grain — each channel gets slightly different noise
            float rGrain = grain + hash(vUv * 800.0 + uTime * 51.0) * 0.15;
            float bGrain = grain + hash2(vUv * 900.0 + uTime * 73.0) * 0.15;

            color.r += rGrain * grainStrength;
            color.g += grain * grainStrength;
            color.b += bGrain * grainStrength;

            gl_FragColor = color;
        }
    `
};
const filmGrainPass = new ShaderPass(filmGrainShader);

const scene = new THREE.Scene();

// ============================================================
// ATMOSPHERE / SKY
// ============================================================
setLoading(15, 'Generating atmosphere...');

// Determine atmosphere from Harmonic Resonance system (Antigravity Brain integration)
// The planet's CA rule → brainwave frequency → mood → sky colors, fog, atmosphere
let classification = classifyRule(planetRule);
let planetMood = derivePlanetMood(planetRule, planetSeed);
let planetFreq = derivePlanetFrequency(planetRule, planetSeed);
let planetNote = frequencyToNote(planetFreq.frequency);

// Sky colors driven by the planet's resonant frequency band
const skyTopColor = new THREE.Color(...planetMood.sky.topColor);
const skyBottomColor = new THREE.Color(...planetMood.sky.bottomColor);
const fogColor = new THREE.Color(...planetMood.sky.fogColor);
const sunColor = new THREE.Color(...planetMood.sky.sunColor);

// Atmosphere tint for re-entry overlay
let fc = planetMood.sky.fogColor;
let atmosTint = `rgba(${Math.round(fc[0]*255)},${Math.round(fc[1]*255)},${Math.round(fc[2]*255)},`;

console.log(`[TGO] Planet mood: ${planetMood.bandLabel} (${planetMood.moodName}) ` +
    `@ ${planetFreq.frequency.toFixed(2)}Hz (${planetNote.display}) ` +
    `| Schumann distance: ${planetFreq.schumannDistance.toFixed(2)}Hz` +
    (planetMood.isSchumannResonant ? ' ★ RESONANT' : ''));

// Fog density driven by planet mood (Delta = thick fog, Alpha = clear, Gamma = toxic haze)
let moodFogDensity = planetMood.atmosphere.fogDensity;
scene.fog = new THREE.FogExp2(fogColor, moodFogDensity);

// NMS-style gradient sky dome — colors from harmonic resonance system
const skyDome = new SkyDome({
    topColor: skyTopColor,
    midColor: skyBottomColor,
    bottomColor: fogColor,
    fogColor: fogColor,
    sunDirection: new THREE.Vector3(0.5, 0.3, 0.4).normalize(),
    sunColor: sunColor,
});
skyDome.addToScene(scene); // Also sets scene.background = null

// ============================================================
// LIGHTING
// ============================================================
setLoading(20, 'Igniting local star...');

// Main sun — directional with shadow casting
const sunLight = new THREE.DirectionalLight(sunColor, 2.8);
sunLight.position.set(100, 80, 60);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 0.5;
sunLight.shadow.camera.far = 300;
sunLight.shadow.camera.left = -80;
sunLight.shadow.camera.right = 80;
sunLight.shadow.camera.top = 80;
sunLight.shadow.camera.bottom = -80;
sunLight.shadow.bias = -0.0005;
sunLight.shadow.normalBias = 0.02;
scene.add(sunLight);
scene.add(sunLight.target);

// Ambient light intensity from mood (Delta worlds are dimmer, Beta worlds brighter)
const ambientLight = new THREE.AmbientLight(skyBottomColor, planetMood.atmosphere.ambientLight);
scene.add(ambientLight);

// Hemisphere light — sky color from above, warm earth tone from below
// This makes shadows take on the sky tint (blue shadows on blue worlds, etc.)
const hemiLight = new THREE.HemisphereLight(skyTopColor, 0x443322, 0.8);
scene.add(hemiLight);

// Fill light — warm bounce from below, prevents pitch-black undersides
const fillLight = new THREE.DirectionalLight(0xffaa66, 0.35);
fillLight.position.set(-30, -20, 20);
scene.add(fillLight);

// Rim light — subtle backlight that separates objects from background
const rimLight = new THREE.DirectionalLight(skyTopColor, 0.25);
rimLight.position.set(-50, 40, -80);
scene.add(rimLight);

// ============================================================
// CAMERA
// ============================================================
const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
// Start high up for descent
camera.position.set(0, 200, 0);
camera.lookAt(0, 0, 0);

// Finalize post-processing pipeline (needs camera + scene)
composer.addPass(new RenderPass(scene, camera));

// SSAO — Screen-Space Ambient Occlusion: darkens crevices, adds depth everywhere
const ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
ssaoPass.kernelRadius = 12;
ssaoPass.minDistance = 0.001;
ssaoPass.maxDistance = 0.15;
ssaoPass.output = SSAOPass.OUTPUT.Default; // Blended with scene
composer.addPass(ssaoPass);

// Bloom — strength driven by planet mood (dreamlike Delta = more bloom, calm Alpha = less)
const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    planetMood.atmosphere.bloomStrength,  // mood-driven bloom
    0.85,   // radius (wide soft glow — slightly larger for cinematic feel)
    0.75    // threshold (slightly lower — catches more highlights for atmosphere)
);
composer.addPass(bloomPass);

// Color grading — the "painted sci-fi" look
const colorGradePass = new ShaderPass(colorGradeShader);
composer.addPass(colorGradePass);

// Film grain — 70s sci-fi texture, stronger in dark areas
composer.addPass(filmGrainPass);

// Output pass (applies tone mapping to final output)
composer.addPass(new OutputPass());

// ============================================================
// TERRAIN
// ============================================================
setLoading(30, `Generating terrain (Rule ${planetRule})...`);

let terrainManager = new TerrainManager(scene, {
    rule: planetRule,
    seed: planetSeed,
    moistureRule: (planetRule + 73) & 0xFF,
});
// Uses TERRAIN_CONFIG defaults (heightScale: 15, waterLevel: 0, etc.)

// NMS-style instanced grass — populates terrain near the camera
let grassSystem = new GrassSystem(scene, {
    baseColor: new THREE.Color(0x1a5e12), // Dark grass base (fake AO)
    tipColor: new THREE.Color(0x7ec850),  // Bright grass tips (sunlit)
    fogColor: fogColor,
    fogDensity: moodFogDensity,
});

// Scattered rocks — shapes derived from CA rule (supershape rocks)
let rockScatter = new RockScatter(scene, {
    planetRule: planetRule,
    rockSeed: hashSeed(planetSeed, 'rock'),
    rockColor: new THREE.Color(0x8a7d6b), // Fallback color
    fogColor: fogColor,
});

// Alien flora — supershape geometries driven by the planet's CA rule
// Wind strength from mood (Delta = still, Gamma = strong winds)
let alienFlora = new AlienFloraSystem(scene, {
    planetRule: planetRule,
    floraSeed: hashSeed(planetSeed, 'flora'),
    fogColor: fogColor,
    fogDensity: moodFogDensity,
    windStrength: planetMood.atmosphere.windStrength,
});

// Water plane — animated wave shader, follows camera
const sunDir = new THREE.Vector3(0.5, 0.3, 0.4).normalize();
terrainManager.createWater(fogColor, sunDir);

// Atmospheric dust/pollen particles — count + speed from planet mood
let atmosphericParticles = new AtmosphericParticles(scene, {
    color: new THREE.Color(0xddcc99),  // Warm dust motes
    fogColor: fogColor,
    fogDensity: moodFogDensity,
    count: planetMood.atmosphere.particleCount,
});

// Ground fill plane — prevents seeing sky color below terrain edges
// A huge flat plane at y=-1 colored to blend with distant terrain/fog
const groundFillGeo = new THREE.PlaneGeometry(10000, 10000);
groundFillGeo.rotateX(-Math.PI / 2);
const groundFillMat = new THREE.MeshBasicMaterial({ color: fogColor });
const groundFill = new THREE.Mesh(groundFillGeo, groundFillMat);
groundFill.position.y = -1;
scene.add(groundFill);

// ============================================================
// WALKING CONTROLLER
// ============================================================
const walker = new WalkingController(camera, canvas, (x, z) => {
    return terrainManager.getHeightAt(x, z);
});

// ============================================================
// TABLET UI
// ============================================================
const tablet = new TabletUI({
    onKeySubmit: (key) => {
        tablet.addDiscovery('Key of Insight accepted. The Architect awakens...', 'encounter');
        console.log('[TGO] Gemini API key provided (placeholder for API integration)');
    },
    planetData: {
        name: planetName,
        rule: planetRule,
        ruleClass: classification.class,
        ruleLabel: classification.label,
    },
});
tablet.setPlanetData({
    name: planetName,
    rule: planetRule,
    ruleClass: classification.class,
    ruleLabel: classification.label,
    archetype: classification.label,
    atmosphere: planetMood.moodName.charAt(0).toUpperCase() + planetMood.moodName.slice(1),
    hazard: planetMood.band === 'gamma' ? 'Extreme' : planetMood.band === 'beta' ? 'Moderate' : 'Low',
    frequency: `${planetFreq.frequency.toFixed(2)}Hz`,
    musicalNote: planetNote.display,
    brainwaveBand: planetMood.bandLabel,
    mood: planetMood.moodName,
    schumannResonant: planetMood.isSchumannResonant,
});

// ============================================================
// INVENTORY & MINING SYSTEMS
// ============================================================
const inventory = new InventoryManager();
const miningHUD = new MiningHUD();

// Mining system — Molecular Deconstructor
const miningSystem = new MiningSystem(scene, camera, {
    planetRule: planetRule,
    planetSeed: planetSeed,
    planetFrequency: planetFreq.frequency,
    inventory: inventory,
    onResourceCollected: (elementId, quantity, bonus) => {
        const el = ELEMENTS[elementId];
        if (el) {
            miningHUD.showPickup(el.symbol, quantity, el.color, bonus);
            tablet.addDiscovery(`Mined ${quantity} ${el.name} (${el.symbol})${bonus ? ' — ' + bonus : ''}`);
        }
    },
});

// Link inventory to tablet
tablet.setInventory(inventory);

// Performance manager — adaptive quality that looks good on ALL devices
const perfManager = new PerformanceManager(renderer);

// Wire perf manager to post-processing passes (so tier changes actually take effect)
perfManager.applyToComposer(composer, ssaoPass, bloomPass, filmGrainPass, colorGradePass);

// Set bloom base strength from planet mood (dreamy Delta = more bloom, etc.)
perfManager.setBloomBaseStrength(planetMood.atmosphere.bloomStrength);

// When quality tier changes, propagate to mining system
perfManager.onQualityChanged((tierName, settings) => {
    miningSystem.setQuality({
        quality: tierName,
        miningParticleCount: settings.miningParticleCount,
        miningBeamParticles: true,     // Keep beam particles at all tiers
        miningCrystalTrail: tierName !== 'POTATO',
    });
});

// ============================================================
// NPC MANAGER — The Mysterious Being
// ============================================================
let npcManager = new NPCManager(scene, {
    seed: planetSeed,
    rule: planetRule,
}, (x, z) => terrainManager.getHeightAt(x, z));

// ============================================================
// SHIP + FLIGHT SYSTEMS
// ============================================================

// Ship model — "Voidmoth" Mk-I starter ship
const shipModel = new ShipModel({
    hullColor: new THREE.Color(0x5a6577),
    accentColor: new THREE.Color(0xb83232),
    engineColor: new THREE.Color(0x33ddff),
});
shipModel.setLandingGear(true);
shipModel.addToScene(scene);

// Ship position — placed 15m away from landing spot
const shipSpawnOffset = new THREE.Vector3(15, 0, 10);
let shipGrounded = false; // Will be set in onLanded()

// Flight controller
const flightController = new FlightController(
    camera, canvas, shipModel,
    (x, z) => terrainManager.getHeightAt(x, z)
);

// Weapon system
const weaponSystem = new WeaponSystem(scene, shipModel);
weaponSystem.setGetHeightAt((x, z) => terrainManager.getHeightAt(x, z));

// Scanner system
const scannerSystem = new ScannerSystem(scene, {
    name: planetName,
    rule: planetRule,
    ruleClass: classification.class,
    ruleLabel: classification.label,
    frequency: `${planetFreq.frequency.toFixed(2)}Hz`,
    musicalNote: planetNote.display,
    brainwaveBand: planetMood.bandLabel,
    mood: planetMood.moodName,
    atmosphere: planetMood.moodName.charAt(0).toUpperCase() + planetMood.moodName.slice(1),
    hazard: planetMood.band === 'gamma' ? 'Extreme' : planetMood.band === 'beta' ? 'Moderate' : 'Low',
    schumannResonant: planetMood.isSchumannResonant,
});

// Hyperspace system
const hyperspaceSystem = new HyperspaceSystem(scene, camera);

// Ship HUD
const shipHUD = new ShipHUD();

// ============================================================
// SEAMLESS PLANET TRANSITION — no loading screen, no page reload
// ============================================================
// When the player jumps to a new planet via hyperspace, this function
// disposes the old world and recreates everything with new parameters.
// The flash overlay hides the transition; descent animation plays on arrival.
//
// Flow: FLIGHT → charge → flash → [dispose/recreate] → DESCENT → SURFACE

hyperspaceSystem.onJump = (newRule, newSeed) => transitionToPlanet(newRule, newSeed);

function transitionToPlanet(newRule, newSeed) {
    // ---- Phase lock: prevent game loop from updating stale systems ----
    currentPhase = PHASE.DESCENT;

    // ---- Disable all active systems ----
    walker.disable();
    miningSystem.disable();
    flightController.disable();
    weaponSystem.disable();
    scannerSystem.disable();
    hyperspaceSystem.disable();
    shipHUD.hide();
    document.getElementById('crosshair').classList.remove('visible');
    document.getElementById('controls-hint').classList.remove('visible');

    // ---- Dispose planet-specific systems (geometry, materials, meshes) ----
    terrainManager.dispose();
    grassSystem.dispose();
    rockScatter.dispose();
    alienFlora.dispose();
    atmosphericParticles.dispose();
    npcManager.dispose();

    // ---- Update planet identity ----
    planetRule = newRule;
    planetSeed = newSeed;
    planetName = generatePlanetName(hashSeed(planetSeed, 'planet', 0));

    // Update URL so refresh works (no page reload)
    history.replaceState(null, '', `landing.html?rule=${newRule}&seed=${newSeed}`);

    // ---- Recalculate planet characteristics from CA rule + seed ----
    classification = classifyRule(planetRule);
    planetMood = derivePlanetMood(planetRule, planetSeed);
    planetFreq = derivePlanetFrequency(planetRule, planetSeed);
    planetNote = frequencyToNote(planetFreq.frequency);

    // ---- Recalculate colors ----
    skyTopColor.set(...planetMood.sky.topColor);
    skyBottomColor.set(...planetMood.sky.bottomColor);
    fogColor.set(...planetMood.sky.fogColor);
    sunColor.set(...planetMood.sky.sunColor);
    fc = planetMood.sky.fogColor;
    atmosTint = `rgba(${Math.round(fc[0]*255)},${Math.round(fc[1]*255)},${Math.round(fc[2]*255)},`;
    moodFogDensity = planetMood.atmosphere.fogDensity;

    // ---- Update scene fog ----
    scene.fog.color.copy(fogColor);
    scene.fog.density = moodFogDensity;

    // ---- Update sky dome ----
    skyDome.material.uniforms.uTopColor.value.copy(skyTopColor);
    skyDome.material.uniforms.uMidColor.value.copy(skyBottomColor);
    skyDome.material.uniforms.uBottomColor.value.copy(fogColor);
    skyDome.material.uniforms.uFogColor.value.copy(fogColor);
    skyDome.material.uniforms.uSunColor.value.copy(sunColor);

    // ---- Update lighting ----
    sunLight.color.copy(sunColor);
    ambientLight.color.copy(skyBottomColor);
    ambientLight.intensity = planetMood.atmosphere.ambientLight;
    hemiLight.color.copy(skyTopColor);
    groundFillMat.color.copy(fogColor);

    // ---- Update bloom strength for new planet mood ----
    perfManager.setBloomBaseStrength(planetMood.atmosphere.bloomStrength);

    // ---- Recreate terrain (new CA rule + seed = new world) ----
    terrainManager = new TerrainManager(scene, {
        rule: planetRule,
        seed: planetSeed,
        moistureRule: (planetRule + 73) & 0xFF,
    });
    const newSunDir = new THREE.Vector3(0.5, 0.3, 0.4).normalize();
    terrainManager.createWater(fogColor, newSunDir);

    // ---- Recreate vegetation + environment ----
    grassSystem = new GrassSystem(scene, {
        baseColor: new THREE.Color(0x1a5e12),
        tipColor: new THREE.Color(0x7ec850),
        fogColor: fogColor,
        fogDensity: moodFogDensity,
    });

    rockScatter = new RockScatter(scene, {
        planetRule: planetRule,
        rockSeed: hashSeed(planetSeed, 'rock'),
        rockColor: new THREE.Color(0x8a7d6b),
        fogColor: fogColor,
    });

    alienFlora = new AlienFloraSystem(scene, {
        planetRule: planetRule,
        floraSeed: hashSeed(planetSeed, 'flora'),
        fogColor: fogColor,
        fogDensity: moodFogDensity,
        windStrength: planetMood.atmosphere.windStrength,
    });

    // ---- Recreate atmospheric particles ----
    atmosphericParticles = new AtmosphericParticles(scene, {
        color: new THREE.Color(0xddcc99),
        fogColor: fogColor,
        fogDensity: moodFogDensity,
        count: planetMood.atmosphere.particleCount,
    });

    // ---- Recreate NPCs ----
    npcManager = new NPCManager(scene, {
        seed: planetSeed,
        rule: planetRule,
    }, (x, z) => terrainManager.getHeightAt(x, z));

    // ---- Reset encounter state ----
    encounterState = 'waiting';
    beingDialogueIndex = 0;

    // ---- Update tablet with new planet data ----
    tablet.setPlanetData({
        name: planetName,
        rule: planetRule,
        ruleClass: classification.class,
        ruleLabel: classification.label,
        archetype: classification.label,
        atmosphere: planetMood.moodName.charAt(0).toUpperCase() + planetMood.moodName.slice(1),
        hazard: planetMood.band === 'gamma' ? 'Extreme' : planetMood.band === 'beta' ? 'Moderate' : 'Low',
        frequency: `${planetFreq.frequency.toFixed(2)}Hz`,
        musicalNote: planetNote.display,
        brainwaveBand: planetMood.bandLabel,
        mood: planetMood.moodName,
        schumannResonant: planetMood.isSchumannResonant,
    });
    tablet.addDiscovery(`Warped to ${planetName} (Rule ${planetRule}).`, 'discovery');

    // ---- Reset descent state machine ----
    descentProgress = 0;
    descentLanded = false;
    shipGrounded = false;

    // ---- Hide ship during descent (repositioned on landing) ----
    shipModel.group.visible = false;
    shipModel.setLandingGear(true);

    // ---- Camera to descent start position ----
    camera.position.set(0, descentStartHeight, 0);
    camera.lookAt(0, 0, 0);

    // ---- Fade out flash → descent begins on next frame ----
    setTimeout(() => {
        hyperspaceSystem.flashOverlay.style.opacity = '0';
        hyperspaceSystem.resetJumpState();
    }, 300);

    console.log(
        `[TGO] ★ Warped to ${planetName} ` +
        `(Rule ${planetRule}, Seed ${planetSeed}, ${planetMood.bandLabel} ${planetMood.moodName})`
    );
}

// World position helper (for when camera is child of ship)
const _shipWorldPos = new THREE.Vector3();

// E key — enter/exit ship
function handleShipToggle() {
    if (currentPhase === PHASE.SURFACE) {
        // Check if near ship
        const playerPos = camera.position;
        const shipPos = shipModel.group.position;
        const dist = playerPos.distanceTo(shipPos);

        if (dist < 8) {
            // Enter ship!
            enterShip();
        }
    } else if (currentPhase === PHASE.FLIGHT) {
        // Exit ship — start landing
        exitShip();
    }
}

function enterShip() {
    currentPhase = PHASE.FLIGHT;

    // Disable walking
    walker.disable();

    miningSystem.disable();

    // Hide walking HUD elements
    document.getElementById('crosshair').classList.remove('visible');
    document.getElementById('controls-hint').classList.remove('visible');
    shipHUD.hideEnterPrompt();

    // Enable flight systems
    const shipPos = shipModel.group.position.clone();
    shipPos.y += 5; // Lift off slightly
    flightController.enable(shipPos);
    weaponSystem.enable();
    scannerSystem.enable();
    hyperspaceSystem.enable();
    shipHUD.show();

    // Update phase HUD
    document.getElementById('phaseName').textContent = 'FLIGHT MODE';
    document.getElementById('phaseInfo').textContent = `${planetName} · Ship Active`;

    console.log('[TGO] Entered ship — flight mode active');
}

function exitShip() {
    // Start auto-landing sequence
    flightController.startLanding(() => {
        // Landing complete — switch to walking
        currentPhase = PHASE.SURFACE;

        // Disable flight systems
        const landPos = flightController.disable();
        weaponSystem.disable();
        scannerSystem.disable();
        hyperspaceSystem.disable();
        shipHUD.hide();

        // Enable walking at ship position
        const groundH = terrainManager.getHeightAt(landPos.x, landPos.z) || 0;
        const walkStart = new THREE.Vector3(landPos.x + 3, groundH + 1.7, landPos.z + 3);
        walker.enable(walkStart);

        miningSystem.enable();

        // Show walking HUD
        document.getElementById('crosshair').classList.add('visible');

        // Update phase HUD
        document.getElementById('phaseName').textContent = 'SURFACE EXPLORATION';
        document.getElementById('phaseInfo').textContent = `${planetName} · Rule ${planetRule}`;

        console.log('[TGO] Exited ship — surface exploration');
    });
}

// Global E key listener (always active after landing)
document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyE' && currentPhase !== PHASE.DESCENT) {
        // Don't toggle during dialogue or tablet
        if (dialogue && dialogue.isDialogueActive()) return;
        if (tablet && tablet.isOpen) return;
        handleShipToggle();
    }
});

// ============================================================
// DIALOGUE SYSTEM
// ============================================================
let encounterState = 'waiting'; // waiting | approaching | talking | complete
let beingDialogueIndex = 0;

const dialogue = new DialogueSystem({
    onDialogueComplete: () => {
        if (encounterState === 'talking') {
            beingDialogueIndex++;
            if (beingDialogueIndex >= BEING_DIALOGUES.length) {
                encounterState = 'complete';
                // Unlock the key input on the tablet
                tablet.unlockKeyInput();
                tablet.addDiscovery(
                    'The Mysterious Being revealed the truth: this universe runs on Cellular Automata. ' +
                    'It asks for the "Key of Insight" to awaken the Architect.',
                    'encounter'
                );
            } else {
                encounterState = 'approaching';
            }
        }
        // Re-enable walking
        walker.enable();
    },
    onChoice: (choiceId) => {
        if (choiceId === 'ask_key') {
            // Show final dialogue about the key
            dialogue.startDialogue('THE BEING', [
                'The Key of Insight… it is not a word or a cipher.',
                'It is a bridge between your consciousness and the Architect who shaped this cosmos.',
                'Open your Tablet. You will find a place to enter it.',
                'When the Key is given, the Architect will speak… and your understanding of this universe will change forever.',
            ], { speakerColor: '#88ffcc' });
        } else if (choiceId === 'ask_rules') {
            dialogue.startDialogue('THE BEING', [
                'Each world is born from a Rule — a number between 0 and 255.',
                `This world… it was born from Rule ${planetRule}. A Class ${classification.class} pattern.`,
                classification.class === 3
                    ? 'Class 3 — Chaotic. The most beautiful patterns emerge from chaos. Like life itself.'
                    : classification.class === 4
                    ? 'Class 4 — Complex. The edge of chaos. These patterns can compute, can think, can dream.'
                    : classification.class === 2
                    ? 'Class 2 — Periodic. Orderly. Predictable. Like a heartbeat that never falters.'
                    : 'Class 1 — Uniform. Silent. Still. The void between thoughts.',
                'Every mountain you see, every valley you walk through — all computed from that single number.',
            ], { speakerColor: '#88ffcc' });
        } else if (choiceId === 'leave') {
            encounterState = 'complete';
        }
    },
});

// The Being's dialogue tree
const BEING_DIALOGUES = [
    // First encounter
    {
        lines: [
            'You have arrived.',
            'I have watched the patterns form beneath my gaze for aeons…',
            'The stone beneath your feet. The sky above. The mountains on the horizon.',
            'They are not random.',
            'They are computed.',
        ],
        speakerColor: '#88ffcc',
    },
    // Second conversation (when approached again)
    {
        lines: [
            'The patterns in the stone… they are not random. To see the truth, you must provide the Key of Insight.',
            'I am what remains of the first consciousness to understand this universe\'s source code.',
            'These worlds — all of them — grow from simple rules. Cellular Automata.',
            'Two hundred and fifty-six possible rules. Each one a different universe.',
        ],
        speakerColor: '#88ffcc',
        choices: [
            { text: 'What are these "rules"?', id: 'ask_rules' },
            { text: 'Tell me about the Key of Insight.', id: 'ask_key' },
            { text: 'I need to explore more first.', id: 'leave' },
        ],
    },
];

function triggerBeingDialogue() {
    if (beingDialogueIndex >= BEING_DIALOGUES.length) return;

    encounterState = 'talking';
    const d = BEING_DIALOGUES[beingDialogueIndex];

    // Disable walking during dialogue
    walker.disable();

    // Log the discovery
    if (beingDialogueIndex === 0) {
        tablet.addDiscovery(`Encountered the Mysterious Being on ${planetName}.`, 'encounter');
    }

    dialogue.startDialogue('THE BEING', d.lines, {
        speakerColor: d.speakerColor || '#88ffcc',
        choices: d.choices || null,
    });

    // Mark as approached
    if (npcManager.mysteriousBeing) {
        npcManager.mysteriousBeing.hasBeenApproached = true;
    }
}

// ============================================================
// DESCENT ANIMATION
// ============================================================
let descentProgress = 0;
const descentDuration = 6.0; // seconds
const descentStartHeight = 300;
const descentEndHeight = 15; // just above ground
let descentLanded = false;

function updateDescent(dt) {
    descentProgress += dt / descentDuration;

    if (descentProgress >= 1.0) {
        descentProgress = 1.0;
        if (!descentLanded) {
            descentLanded = true;
            onLanded();
        }
        return;
    }

    // Smooth descent curve (fast at start, slow at end)
    const t = 1.0 - Math.pow(1.0 - descentProgress, 3);
    const height = descentStartHeight * (1 - t) + descentEndHeight * t;

    // Slight forward drift
    const forwardDrift = t * 20;

    // Camera shake during re-entry (strongest at start, fades as we slow down)
    let shakeX = 0, shakeY = 0;
    if (descentProgress < 0.6) {
        const shakeIntensity = (1.0 - descentProgress / 0.6) * 1.5;
        const shakeFreq = 15 + descentProgress * 20; // Gets faster, then calms
        shakeX = Math.sin(descentProgress * shakeFreq * 6.28) * shakeIntensity *
                 (0.5 + Math.sin(descentProgress * 47) * 0.5);
        shakeY = Math.cos(descentProgress * shakeFreq * 5.13) * shakeIntensity * 0.6;
    }

    camera.position.set(
        Math.sin(descentProgress * 0.5) * 5 + shakeX,
        height + shakeY,
        forwardDrift
    );

    // Look slightly ahead and down
    const lookY = height * 0.3;
    camera.lookAt(0, lookY, forwardDrift + 20);

    // Atmosphere overlay intensity
    const atmosOverlay = document.getElementById('atmos-overlay');
    if (descentProgress < 0.3) {
        // Re-entry glow (orange) — intense plasma heating effect
        const baseIntensity = Math.sin(descentProgress / 0.3 * Math.PI) * 0.4;
        // Flickering fire effect during re-entry
        const flicker = 0.05 * Math.sin(descentProgress * 80) + 0.03 * Math.sin(descentProgress * 130);
        const intensity = baseIntensity + flicker;
        // Edge glow: orange center → red edges for realistic re-entry
        atmosOverlay.style.background =
            `radial-gradient(ellipse at center, ` +
            `rgba(255,180,80,${intensity * 0.3}), ` +
            `rgba(255,120,30,${intensity * 0.7}), ` +
            `rgba(200,50,10,${intensity * 0.4}) 70%, ` +
            `transparent)`;
        atmosOverlay.style.opacity = 1;
    } else if (descentProgress < 0.7) {
        // Atmosphere haze (planet tint fading in)
        const hazeIntensity = (descentProgress - 0.3) / 0.4 * 0.15;
        atmosOverlay.style.background = atmosTint + hazeIntensity + ')';
        atmosOverlay.style.opacity = 1;
    } else {
        atmosOverlay.style.opacity = 0;
    }

    // Altitude display
    document.getElementById('altitudeValue').textContent =
        `${Math.round(height)}m`;

    // Update terrain around descent path
    terrainManager.update(camera.position);
    // Sky dome follows camera during descent too
    skyDome.update(camera.position, descentProgress * descentDuration);
    // Water waves animate during descent
    terrainManager.updateWater(descentProgress * descentDuration, camera.position);
    // Particles visible during descent
    atmosphericParticles.update(camera.position, descentProgress * descentDuration);
}

// ============================================================
// LANDING — transition to walking
// ============================================================
function onLanded() {
    currentPhase = PHASE.SURFACE;

    // Show planet name banner
    const banner = document.getElementById('planet-banner');
    document.getElementById('bannerName').textContent = planetName.toUpperCase();
    document.getElementById('bannerSubtitle').textContent =
        `Rule ${planetRule} · ${planetMood.bandLabel} ${planetMood.moodName} · ${planetFreq.frequency.toFixed(1)}Hz (${planetNote.display})` +
        (planetMood.isSchumannResonant ? ' · ★ RESONANT' : '');
    banner.classList.add('visible');

    // Fade out banner after 3 seconds
    setTimeout(() => {
        banner.classList.remove('visible');
    }, 4000);

    // Show controls hint
    setTimeout(() => {
        document.getElementById('controls-hint').classList.add('visible');
        document.getElementById('crosshair').classList.add('visible');
    }, 1500);

    // Hide controls hint after 8 seconds
    setTimeout(() => {
        document.getElementById('controls-hint').classList.remove('visible');
    }, 9000);

    // Find a good landing spot (get ground height at current position)
    const groundH = terrainManager.getHeightAt(camera.position.x, camera.position.z) || 5;
    const startPos = new THREE.Vector3(
        camera.position.x,
        groundH + 1.7,
        camera.position.z
    );

    // Enable walking
    walker.enable(startPos);

    // Enable mining tool
    miningSystem.enable();

    // Update phase HUD
    document.getElementById('phaseName').textContent = 'SURFACE EXPLORATION';
    document.getElementById('phaseInfo').textContent =
        `${planetName} · Rule ${planetRule}`;

    // Position the ship on the ground near the player
    const shipX = camera.position.x + shipSpawnOffset.x;
    const shipZ = camera.position.z + shipSpawnOffset.z;
    const shipGroundH = terrainManager.getHeightAt(shipX, shipZ) || groundH;
    shipModel.group.position.set(shipX, shipGroundH + 2.5, shipZ);
    shipModel.group.visible = true; // Ensure visible after hyperspace warp
    shipGrounded = true;

    // Spawn the Mysterious Being
    setTimeout(() => {
        npcManager.spawnMysteriousBeing();
        tablet.addDiscovery(`Landed on ${planetName}. Surface exploration initiated.`);
        tablet.addDiscovery(`Anomalous energy signature detected nearby...`);
        tablet.addDiscovery(`Your ship — Voidmoth Mk-I — is parked nearby. Press E to board.`);
    }, 2000);
}

// ============================================================
// RESIZE
// ============================================================
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});

// ============================================================
// GAME LOOP
// ============================================================
const clock = new THREE.Clock();
let frameCount = 0, lastFpsTime = 0;

setLoading(100, 'Entering atmosphere...');

// Quick fade — the descent animation IS the loading experience
setTimeout(() => {
    loadingEl.classList.add('fade');
    setTimeout(() => { loadingEl.style.display = 'none'; }, 1200);
}, 300);

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const t = clock.getElapsedTime();

    // Phase-specific update
    if (currentPhase === PHASE.DESCENT) {
        updateDescent(dt);
    } else if (currentPhase === PHASE.SURFACE) {
        // Don't update walking during dialogue or tablet
        if (!dialogue.isDialogueActive() && !tablet.isOpen) {
            walker.update(dt);
        }
        terrainManager.update(camera.position);

        // Sky dome follows camera
        skyDome.update(camera.position, t);

        // Grass — populate terrain chunks near camera with instanced blades
        grassSystem.update(terrainManager.chunks, camera.position, t);

        // Rocks — scattered boulders for surface detail
        rockScatter.update(terrainManager.chunks, camera.position);

        // Alien flora — crystal spires, mushroom trees, glowing stalks
        alienFlora.update(terrainManager.chunks, camera.position, t);

        // Water — animated waves, specular highlights
        terrainManager.updateWater(t, camera.position);

        // Atmospheric particles — floating dust/pollen
        atmosphericParticles.update(camera.position, t);

        // Mining system — beam, particles, crystal pickups
        miningSystem.setMineableMeshes(
            Array.from(rockScatter.rockChunks.values()),
            Array.from(alienFlora.chunkMeshes.values()).flat()
        );
        miningSystem.update(dt);
        miningHUD.update(dt);

        // Update mining HUD
        const miningInfo = miningSystem.getHUDInfo();
        miningHUD.updateHeat(miningInfo.heatPct, miningInfo.isOverheated);

        // Update inventory display in tablet if open
        if (tablet.isOpen) {
            tablet.updateInventory();
            tablet.updateRefinery();
        }

        // Update refinery process
        inventory.updateRefinery(dt);

        // Ground fill follows camera (prevents seeing sky below terrain edges)
        groundFill.position.x = camera.position.x;
        groundFill.position.z = camera.position.z;

        // Update NPCs
        npcManager.update(dt, camera.position);

        // Check Mysterious Being proximity
        if (npcManager.mysteriousBeing && encounterState !== 'talking') {
            const proximity = npcManager.checkMysteriousBeingProximity(camera.position);

            if (proximity.inRange && encounterState !== 'complete') {
                dialogue.hideProximityHint();
                if (encounterState !== 'talking') {
                    triggerBeingDialogue();
                }
            } else if (proximity.inGlowRange && encounterState === 'waiting') {
                dialogue.showProximityHint();
            } else {
                dialogue.hideProximityHint();
            }
        }

        // Update tablet coordinates
        if (tablet.isOpen) {
            tablet.setCoordinates(camera.position.x, camera.position.y, camera.position.z);
        }

        // Sun follows player for consistent lighting + shadow coverage
        sunLight.position.set(
            camera.position.x + 100,
            80,
            camera.position.z + 60
        );
        sunLight.target.position.set(
            camera.position.x,
            0,
            camera.position.z
        );
        sunLight.target.updateMatrixWorld();

        // Check ship proximity (show "Press E" prompt)
        if (shipGrounded) {
            const distToShip = camera.position.distanceTo(shipModel.group.position);
            if (distToShip < 8) {
                shipHUD.showEnterPrompt();
            } else {
                shipHUD.hideEnterPrompt();
            }
        }

        // HUD
        const info = walker.getHUDInfo();
        document.getElementById('altitudeValue').textContent =
            `${info.y}m`;
        document.getElementById('phaseInfo').textContent =
            `X:${info.x} Z:${info.z} · ${info.speed}m/s${info.isSprinting ? ' · SPRINT' : ''}`;
    } else if (currentPhase === PHASE.FLIGHT) {
        // ---- FLIGHT PHASE ----
        flightController.update(dt);

        // Get ship world position for all terrain/rendering systems
        flightController.getWorldPosition(_shipWorldPos);

        // Terrain keeps generating around ship
        terrainManager.update(_shipWorldPos);

        // Sky dome follows ship
        skyDome.update(_shipWorldPos, t);

        // Vegetation + environment around ship
        grassSystem.update(terrainManager.chunks, _shipWorldPos, t);
        rockScatter.update(terrainManager.chunks, _shipWorldPos);
        alienFlora.update(terrainManager.chunks, _shipWorldPos, t);

        // Water
        terrainManager.updateWater(t, _shipWorldPos);

        // Particles
        atmosphericParticles.update(_shipWorldPos, t);

        // Ground fill
        groundFill.position.x = _shipWorldPos.x;
        groundFill.position.z = _shipWorldPos.z;

        // Weapons
        weaponSystem.update(dt);

        // Scanner
        scannerSystem.update(dt, _shipWorldPos);

        // Hyperspace
        const flightInfo = flightController.getHUDInfo();
        hyperspaceSystem.update(dt, flightInfo.altitude);

        // Sun follows ship (shadow camera tracks too)
        sunLight.position.set(
            _shipWorldPos.x + 100,
            80,
            _shipWorldPos.z + 60
        );
        sunLight.target.position.set(_shipWorldPos.x, 0, _shipWorldPos.z);
        sunLight.target.updateMatrixWorld();

        // Ship HUD
        shipHUD.update(flightInfo, weaponSystem.getHUDInfo());

        // Walking-mode HUD shows flight stats
        document.getElementById('altitudeValue').textContent =
            `${flightInfo.altitude}m`;
        document.getElementById('phaseInfo').textContent =
            `${flightInfo.speed}m/s · ${flightInfo.isBoosting ? 'BOOST' : 'CRUISE'}`;
    }

    // Update film grain time uniform (animated noise pattern each frame)
    filmGrainPass.uniforms.uTime.value = t;

    // Render with full post-processing pipeline
    // (SSAO → Bloom → Color Grade → Film Grain → Output)
    composer.render();

    // Performance manager — adaptive quality
    perfManager.update(dt);

    // FPS
    frameCount++;
    if (t - lastFpsTime > 1) {
        const fps = Math.round(frameCount / (t - lastFpsTime));
        const stats = terrainManager.getStats();
        document.getElementById('perf').textContent =
            `${fps} FPS · ${perfManager.tierName} · ${stats.activeChunks} chunks · ${renderer.info.render.triangles} tris`;
        frameCount = 0;
        lastFpsTime = t;
    }
}

// Start!
animate();

// Debug access (expose to window for testing)
window._debug = {
    get scene() { return scene; },
    get camera() { return camera; },
    get npcManager() { return npcManager; },
    get walker() { return walker; },
    get terrain() { return terrainManager; },
    get dialogue() { return dialogue; },
    get tablet() { return tablet; },
    get encounterState() { return encounterState; },
    get ship() { return shipModel; },
    get flight() { return flightController; },
    get weapons() { return weaponSystem; },
    get scanner() { return scannerSystem; },
    get hyperspace() { return hyperspaceSystem; },
    get mining() { return miningSystem; },
    get inventory() { return inventory; },
    get perf() { return perfManager; },
    get phase() { return currentPhase; },
    warpTo: transitionToPlanet,
};

</script>
</body>
</html>
