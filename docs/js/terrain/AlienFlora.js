/**
 * THE GALACTIC ORDER - Alien Flora System (Supershape Edition)
 *
 * Procedural alien plants where the SHAPE is generated by the planet's
 * CA rule via the Superformula. Every planet has unique flora because
 * the rule number drives the shape parameters.
 *
 * Architecture:
 * 1. On init: deriveShapeVariants(planetRule, floraSeed) → 5 shape param sets
 * 2. createSupershapeGeometry(params) → 5 unique BufferGeometries
 * 3. Each gets a material colored by deriveShapeColors(rule, seed)
 * 4. Scattered across terrain via InstancedMesh (same as before)
 *
 * The 5 variants per planet ensures visual variety while keeping a
 * consistent "DNA" — all shapes on Rule 30 planets look organic/chaotic,
 * all shapes on Rule 90 planets look crystalline/geometric, etc.
 *
 * Additionally, each variant can have a "stalk" (cylinder trunk) beneath it
 * for tree-like plants, controlled by the feature flags from the rule bits.
 */

import * as THREE from 'three';
import { hashSeed } from '../generation/hashSeed.js';
import { TERRAIN_CONFIG } from './TerrainChunk.js';
import { createSupershapeGeometry, normalizeGeometry } from '../generation/superformula.js';
import { deriveShapeVariants, deriveShapeColors, deriveFeatureFlags } from '../generation/caShapeParams.js';

// ============================================================
// CONFIGURATION
// ============================================================

const FLORA_CONFIG = {
    floraRadius: 3,
    plantsPerChunk: 14,
    variantCount: 5,      // Number of unique shapes per planet
    shapeResolution: 20,  // Supershape mesh detail (20 = ~800 tris, good for instancing)

    biomeDensity: {
        2: 0.1,   // Beach
        3: 0.2,   // Desert
        4: 0.5,   // Savanna
        5: 0.8,   // Grassland
        6: 1.0,   // Forest
        7: 0.9,   // Dense Forest
        8: 0.7,   // Swamp
        9: 0.4,   // Mountain
        10: 0.2,  // Snow Peak
        11: 0.3,  // Ice
    },
};

// ============================================================
// STALK (TRUNK) GEOMETRY — for tree-like flora
// ============================================================

function createStalkGeometry(height = 1.5, radiusBottom = 0.08, radiusTop = 0.05) {
    const geo = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 5, 2);
    const pos = geo.getAttribute('position');

    // Gentle curve for organic feel
    for (let i = 0; i < pos.count; i++) {
        const y = pos.getY(i);
        const t = (y + height / 2) / height; // 0 at bottom, 1 at top
        const lean = Math.pow(t, 2) * 0.15;
        pos.setX(i, pos.getX(i) + lean);
    }

    geo.computeVertexNormals();
    return geo;
}

// ============================================================
// ALIEN FLORA SYSTEM
// ============================================================

export class AlienFloraSystem {
    /**
     * @param {THREE.Scene} scene
     * @param {Object} options
     * @param {number} options.planetRule - The CA rule number (0-255)
     * @param {number} options.floraSeed - The planet's flora seed
     * @param {THREE.Color} options.fogColor
     * @param {number} options.fogDensity
     */
    constructor(scene, options = {}) {
        this.scene = scene;
        this.config = { ...FLORA_CONFIG };

        const planetRule = options.planetRule || 110;
        const floraSeed = options.floraSeed || 42;
        const windStrength = options.windStrength || 0.15;
        const flags = deriveFeatureFlags(planetRule);

        // Generate 5 unique shape variants from the CA rule
        const shapeVariants = deriveShapeVariants(
            planetRule, floraSeed, this.config.variantCount, 'flora'
        );

        // Build geometry + material for each variant
        this.floraTypes = [];

        for (let v = 0; v < shapeVariants.length; v++) {
            const variant = shapeVariants[v];
            const colors = deriveShapeColors(planetRule, hashSeed(floraSeed, 'color', v));

            // Generate the supershape geometry with modifiers
            let geo;
            try {
                const modifiers = variant.modifiers || {};
                geo = createSupershapeGeometry(
                    variant.params1, variant.params2, this.config.shapeResolution, modifiers
                );
                normalizeGeometry(geo); // Fit to 1×1×1 bounding box
            } catch (e) {
                // Fallback to icosahedron if supershape params produce degenerate mesh
                geo = new THREE.IcosahedronGeometry(0.5, 1);
            }

            // Check if this variant gets a stalk (tree-like)
            const hasTrunk = v < 2 && !flags.isFlat; // First 2 variants get trunks
            if (hasTrunk) {
                // Merge stalk + supershape cap into one geometry
                // Taller trunks so trees tower over the player
                const stalkHeight = 2.5 + (v * 1.0);
                const stalk = createStalkGeometry(stalkHeight, 0.12, 0.08);
                geo = mergeGeometries(stalk, geo, stalkHeight * 0.5 + 0.4);
            }

            // Create material with wind sway (custom ShaderMaterial)
            const baseColor = new THREE.Color(colors.primary[0], colors.primary[1], colors.primary[2]);
            const hasGlow = flags.hasEmissiveGlow && v % 2 === 0;
            const emissiveColor = hasGlow
                ? new THREE.Color(colors.emissive[0], colors.emissive[1], colors.emissive[2])
                : new THREE.Color(0, 0, 0);

            // Accent color for variation
            const accentColor = colors.accent
                ? new THREE.Color(colors.accent[0], colors.accent[1], colors.accent[2])
                : baseColor.clone().multiplyScalar(0.8);

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uColor: { value: baseColor },
                    uAccentColor: { value: accentColor },
                    uEmissive: { value: emissiveColor },
                    uEmissiveIntensity: { value: hasGlow ? 0.4 : 0.0 },
                    uRoughness: { value: colors.roughness },
                    uMetalness: { value: colors.metalness },
                    uTime: { value: 0.0 },
                    uWindStrength: { value: windStrength },
                    uOpacity: { value: colors.opacity },
                },
                vertexShader: /* glsl */ `
                    uniform float uTime;
                    uniform float uWindStrength;

                    attribute vec3 color;

                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    varying vec3 vViewDir;
                    varying vec3 vVertexColor;
                    varying float vHeightFactor;

                    void main() {
                        vec3 pos = position;

                        // Wind sway — stronger at top of plant (higher Y)
                        float heightFactor = max(0.0, pos.y + 0.5);
                        heightFactor = heightFactor * heightFactor;
                        vHeightFactor = heightFactor;

                        // Multi-frequency wind with instance-based phase
                        vec4 worldPos4 = instanceMatrix * vec4(pos, 1.0);
                        float phase = worldPos4.x * 0.1 + worldPos4.z * 0.13;

                        float wind1 = sin(uTime * 1.2 + phase) * 0.7;
                        float wind2 = sin(uTime * 2.5 + phase * 1.5) * 0.3;
                        float gust = sin(uTime * 0.4 + phase * 0.3);
                        gust *= gust;

                        float windOffset = (wind1 + wind2) * uWindStrength * heightFactor * (0.6 + gust * 0.4);

                        pos.x += windOffset;
                        pos.z += windOffset * 0.5;

                        // Apply instance transform
                        vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
                        vWorldPosition = (modelMatrix * instanceMatrix * vec4(pos, 1.0)).xyz;
                        vNormal = normalize(normalMatrix * mat3(instanceMatrix) * normal);
                        vViewDir = normalize(cameraPosition - vWorldPosition);
                        vVertexColor = color;

                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: /* glsl */ `
                    uniform vec3 uColor;
                    uniform vec3 uAccentColor;
                    uniform vec3 uEmissive;
                    uniform float uEmissiveIntensity;
                    uniform float uRoughness;
                    uniform float uMetalness;
                    uniform float uOpacity;

                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    varying vec3 vViewDir;
                    varying vec3 vVertexColor;
                    varying float vHeightFactor;

                    void main() {
                        vec3 N = normalize(vNormal);
                        vec3 V = normalize(vViewDir);
                        vec3 lightDir = normalize(vec3(0.5, 0.8, 0.3));

                        // Blend base color with accent using vertex color variation
                        vec3 baseCol = mix(uColor, uAccentColor, vVertexColor.g * 0.4 + vHeightFactor * 0.2);

                        // Diffuse (wrapped for softer look — half-Lambert)
                        float NdotL = dot(N, lightDir);
                        float halfLambert = NdotL * 0.5 + 0.5;
                        halfLambert *= halfLambert; // Square for gentle falloff

                        // Hemisphere ambient (sky above, ground below)
                        float upFactor = dot(N, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5;
                        vec3 ambient = mix(vec3(0.08, 0.06, 0.04), vec3(0.15, 0.2, 0.28), upFactor);

                        vec3 diffuse = baseCol * halfLambert * 0.7;

                        // Subsurface scattering hint — light shining through thin surfaces
                        float sss = pow(max(dot(V, -lightDir), 0.0), 3.0);
                        sss *= (1.0 - uMetalness) * 0.25;
                        vec3 sssColor = baseCol * vec3(1.2, 1.0, 0.8) * sss;

                        // Specular (Blinn-Phong) — sharper for metallic, broader for rough
                        vec3 H = normalize(lightDir + V);
                        float specPower = mix(16.0, 128.0, 1.0 - uRoughness);
                        float spec = pow(max(dot(N, H), 0.0), specPower);
                        float specIntensity = mix(0.15, 0.6, uMetalness);
                        vec3 specColor = mix(vec3(0.9, 0.92, 1.0), baseCol, uMetalness) * spec * specIntensity;

                        // Fresnel rim — edge glow for alien feel
                        float fresnel = pow(1.0 - max(dot(V, N), 0.0), 4.0);
                        vec3 rimColor = mix(vec3(0.1, 0.15, 0.25), uAccentColor, 0.3) * fresnel * 0.3;

                        vec3 color = diffuse + ambient * baseCol * 0.3 + sssColor + specColor + rimColor;

                        // Emissive glow
                        color += uEmissive * uEmissiveIntensity;

                        gl_FragColor = vec4(color, uOpacity);
                    }
                `,
                transparent: colors.opacity < 1.0,
                side: THREE.DoubleSide,
            });

            // Scale and shape characteristics based on variant index
            // Larger values so flora towers over the player (1.7m eye height)
            const baseScales = [3.5, 2.8, 2.0, 1.4, 0.8]; // Decreasing size per variant
            const scaleVars = [2.5, 2.0, 1.5, 1.0, 0.6];

            this.floraTypes.push({
                name: `variant_${v}_${variant.style}`,
                geometry: geo,
                material: mat,
                baseScale: baseScales[v] * (flags.isTall ? 1.5 : 1.0),
                scaleVariation: scaleVars[v],
                hasGlow,
            });
        }

        this.processedChunks = new Set();
        this.chunkMeshes = new Map();
    }

    update(terrainChunks, cameraPosition, time) {
        const floraRadius = this.config.floraRadius;
        const chunkWorldSize = TERRAIN_CONFIG.chunkWorldSize;

        const camChunkX = Math.floor(cameraPosition.x / chunkWorldSize);
        const camChunkZ = Math.floor(cameraPosition.z / chunkWorldSize);

        const desiredKeys = new Set();
        for (let dx = -floraRadius; dx <= floraRadius; dx++) {
            for (let dz = -floraRadius; dz <= floraRadius; dz++) {
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist > floraRadius) continue;
                desiredKeys.add(`0:${camChunkX + dx}:${camChunkZ + dz}`);
            }
        }

        // Remove out-of-range chunks
        for (const [key, meshes] of this.chunkMeshes) {
            if (!desiredKeys.has(key)) {
                for (const mesh of meshes) {
                    this.scene.remove(mesh);
                }
                this.chunkMeshes.delete(key);
                this.processedChunks.delete(key);
            }
        }

        // Generate flora for new chunks
        for (const [key, chunk] of terrainChunks) {
            if (!desiredKeys.has(key)) continue;
            if (this.processedChunks.has(key)) continue;
            if (chunk.state !== 'ready') continue;
            if (!chunk.elevation || !chunk.biomeIds) continue;

            this._generateFloraForChunk(chunk, key);
        }

        // Update time uniform for wind sway + animate emissive glow
        for (const ft of this.floraTypes) {
            if (ft.material.uniforms) {
                ft.material.uniforms.uTime.value = time;
                if (ft.hasGlow) {
                    ft.material.uniforms.uEmissiveIntensity.value = 0.25 + Math.sin(time * 1.5) * 0.2;
                }
            }
        }
    }

    _generateFloraForChunk(chunk, key) {
        this.processedChunks.add(key);

        const dataRes = Math.round(Math.sqrt(chunk.elevation.length));
        const worldSize = chunk.worldSize;
        const wl = TERRAIN_CONFIG.waterLevel;
        const hs = TERRAIN_CONFIG.heightScale;
        const numVariants = this.floraTypes.length;

        // Collect plants by variant type
        const plantsByType = Array.from({ length: numVariants }, () => []);

        for (let i = 0; i < this.config.plantsPerChunk * 3; i++) {
            const seed = hashSeed(key, i, 'flora');
            const rx = (seed & 0xFFFF) / 0x10000;
            const rz = ((seed >> 16) & 0xFFFF) / 0x10000;

            const gx = Math.floor(rx * (dataRes - 1));
            const gz = Math.floor(rz * (dataRes - 1));
            const idx = gz * dataRes + gx;

            const biomeId = chunk.biomeIds[idx];
            const density = this.config.biomeDensity[biomeId] || 0;
            if (density <= 0) continue;

            const dSeed = hashSeed(seed, 'fdensity');
            if ((dSeed & 0xFF) / 255 > density) continue;

            // Height (same formula as terrain)
            const elevation = chunk.elevation[idx] || 0;
            let height = 0;
            if (elevation > wl + 0.05) {
                const normalizedElev = (elevation - wl) / (1.0 - wl);
                height = Math.pow(normalizedElev, 1.4) * hs;
                if (elevation > 0.75) height += (elevation - 0.75) * hs * 0.6;
            } else if (elevation >= wl - 0.05) {
                const t = (elevation - (wl - 0.05)) / 0.10;
                const smoothT = t * t * (3 - 2 * t);
                height = smoothT * 0.3;
            } else {
                continue; // Skip underwater
            }

            // Select which variant to use
            // Weighted: larger variants are rarer, smallest are common
            const typeSeed = hashSeed(seed, 'ftype');
            const typeRoll = (typeSeed & 0xFF) / 255;
            let variantIdx;
            if (typeRoll < 0.15) variantIdx = 0;       // 15% — largest, rarest
            else if (typeRoll < 0.35) variantIdx = 1;   // 20%
            else if (typeRoll < 0.55) variantIdx = 2;   // 20%
            else if (typeRoll < 0.78) variantIdx = 3;   // 23%
            else variantIdx = 4;                         // 22% — smallest, most common

            if (variantIdx >= numVariants) variantIdx = numVariants - 1;

            const worldX = chunk.worldX + (rx - 0.5) * worldSize;
            const worldZ = chunk.worldZ + (rz - 0.5) * worldSize;

            const scaleSeed = hashSeed(seed, 'fscale');
            const ft = this.floraTypes[variantIdx];
            const scale = ft.baseScale + ((scaleSeed & 0xFF) / 255) * ft.scaleVariation;

            const rotSeed = hashSeed(seed, 'frot');
            const rotY = ((rotSeed & 0xFFFF) / 0x10000) * Math.PI * 2;

            const tiltSeed = hashSeed(seed, 'ftilt');
            const tiltX = ((tiltSeed & 0xFF) / 255 - 0.5) * 0.2;
            const tiltZ = (((tiltSeed >> 8) & 0xFF) / 255 - 0.5) * 0.2;

            plantsByType[variantIdx].push({
                worldX, worldZ, height, scale, rotY, tiltX, tiltZ,
            });

            const total = plantsByType.reduce((s, arr) => s + arr.length, 0);
            if (total >= this.config.plantsPerChunk) break;
        }

        // Create instanced meshes per variant
        const meshes = [];
        const dummy = new THREE.Object3D();

        for (let type = 0; type < numVariants; type++) {
            const plants = plantsByType[type];
            if (plants.length === 0) continue;

            const ft = this.floraTypes[type];
            const instancedMesh = new THREE.InstancedMesh(
                ft.geometry, ft.material, plants.length
            );
            instancedMesh.frustumCulled = true;

            for (let j = 0; j < plants.length; j++) {
                const p = plants[j];
                dummy.position.set(p.worldX, p.height, p.worldZ);
                dummy.rotation.set(p.tiltX, p.rotY, p.tiltZ);
                dummy.scale.setScalar(p.scale);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(j, dummy.matrix);
            }

            instancedMesh.instanceMatrix.needsUpdate = true;
            this.scene.add(instancedMesh);
            meshes.push(instancedMesh);
        }

        if (meshes.length > 0) {
            this.chunkMeshes.set(key, meshes);
        }
    }

    dispose() {
        for (const [, meshes] of this.chunkMeshes) {
            for (const mesh of meshes) {
                this.scene.remove(mesh);
            }
        }
        this.chunkMeshes.clear();
        this.processedChunks.clear();

        for (const ft of this.floraTypes) {
            ft.geometry.dispose();
            ft.material.dispose();
        }
    }
}

// ============================================================
// UTILITY: Merge two geometries vertically
// ============================================================

function mergeGeometries(bottomGeo, topGeo, topOffset) {
    const bPos = bottomGeo.getAttribute('position');
    const tPos = topGeo.getAttribute('position');
    const bNorm = bottomGeo.getAttribute('normal');
    const tNorm = topGeo.getAttribute('normal');
    const bIdx = bottomGeo.getIndex();
    const tIdx = topGeo.getIndex();

    const totalVerts = bPos.count + tPos.count;
    const positions = new Float32Array(totalVerts * 3);
    const normals = new Float32Array(totalVerts * 3);

    // Copy bottom
    for (let i = 0; i < bPos.count; i++) {
        positions[i * 3] = bPos.getX(i);
        positions[i * 3 + 1] = bPos.getY(i);
        positions[i * 3 + 2] = bPos.getZ(i);
        normals[i * 3] = bNorm.getX(i);
        normals[i * 3 + 1] = bNorm.getY(i);
        normals[i * 3 + 2] = bNorm.getZ(i);
    }

    // Copy top (offset Y)
    const offset = bPos.count;
    for (let i = 0; i < tPos.count; i++) {
        positions[(offset + i) * 3] = tPos.getX(i);
        positions[(offset + i) * 3 + 1] = tPos.getY(i) + topOffset;
        positions[(offset + i) * 3 + 2] = tPos.getZ(i);
        normals[(offset + i) * 3] = tNorm.getX(i);
        normals[(offset + i) * 3 + 1] = tNorm.getY(i);
        normals[(offset + i) * 3 + 2] = tNorm.getZ(i);
    }

    const merged = new THREE.BufferGeometry();
    merged.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    merged.setAttribute('normal', new THREE.BufferAttribute(normals, 3));

    // Combine indices
    const bottomIndices = bIdx ? Array.from(bIdx.array) : [];
    const topIndices = tIdx ? Array.from(tIdx.array).map(i => i + offset) : [];
    if (bottomIndices.length > 0 || topIndices.length > 0) {
        merged.setIndex([...bottomIndices, ...topIndices]);
    }

    merged.computeVertexNormals();
    return merged;
}
