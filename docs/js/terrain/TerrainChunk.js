/**
 * THE GALACTIC ORDER - Terrain Chunk System (Pioneer-Style Quadtree LOD)
 *
 * Upgraded from single-LOD to a true quadtree that subdivides
 * terrain into chunks at different levels of detail, inspired by
 * Pioneer Space Sim's planetary LOD system.
 *
 * Pioneer's approach (translated to our CA-based terrain):
 * 1. Start with large root chunks covering the entire visible area
 * 2. Chunks NEAR the camera SPLIT into 4 children (higher detail)
 * 3. Chunks FAR from the camera MERGE back (lower detail)
 * 4. Each chunk's heightmap is generated by CA rules via WebWorker
 * 5. Split/merge decisions use a hysteresis band to prevent popping
 *
 * Quadtree structure:
 *   Level 0: 1 chunk covering 512m x 512m (far away)
 *   Level 1: 4 chunks of 256m x 256m
 *   Level 2: 16 chunks of 128m x 128m
 *   Level 3: 64 chunks of 64m x 64m (near camera)
 *   Level 4: 256 chunks of 32m x 32m (right under player — max detail)
 *
 * The key insight from Pioneer: the split distance for each level
 * is proportional to the chunk size, so you always have roughly
 * the same triangle density on screen regardless of distance.
 */

import * as THREE from 'three';
import { hashSeed, seededRandom } from '../generation/hashSeed.js';

// ============================================================
// CONFIGURATION
// ============================================================

export const TERRAIN_CONFIG = {
    // Base chunk size in world units (Level 0 = root)
    chunkWorldSize: 64,

    // Heightmap resolution per chunk
    chunkResolution: 33, // 33 = 32 cells + 1 for stitching

    // View radius in chunks (how far terrain extends around the player)
    viewRadius: 6,

    // Height scale multiplier (taller = more impressive terrain, player feels small)
    heightScale: 40.0,

    // Water level (0-1 in heightmap space) — 0 = no water, all land
    waterLevel: 0.0,

    // Maximum active chunks (memory budget)
    maxChunks: 250,

    // === Pioneer-style Quadtree LOD ===
    // Maximum quadtree depth (0 = root only, 4 = max detail)
    maxQuadtreeDepth: 4,

    // Split distance multiplier — chunk splits when camera is closer
    // than (chunkSize * splitDistanceMultiplier)
    // Pioneer uses ~2.0; we use 2.5 for smoother transitions
    splitDistanceMultiplier: 2.5,

    // Hysteresis factor — chunk must be this much further to merge back
    // Prevents rapid split/merge oscillation at boundary distances
    // Higher value = more stable chunks, less popping when approaching
    mergeHysteresis: 1.8,

    // Root chunk size at level 0 (covers wide area)
    rootChunkSize: 512,

    // LOD bias — shift split distances (< 1 = more detail, > 1 = less)
    lodBias: 1.0,

    // === Adaptive LOD ===
    // Target FPS for adaptive quality (auto-adjusts lodBias)
    adaptiveTargetFPS: 55,
    // Minimum LOD bias (highest quality ceiling)
    adaptiveLodMin: 0.6,
    // Maximum LOD bias (lowest quality floor)
    adaptiveLodMax: 2.5,

    // === Chunk pooling ===
    // Number of disposed chunks to keep in pool for reuse
    chunkPoolSize: 32,

    // === Skirt geometry ===
    // Depth of skirt below chunk edges to hide LOD cracks
    skirtDepth: 5.0,
};

// ============================================================
// NMS-STYLE BIOME COLORS (for terrain vertex coloring)
// ============================================================

const NMS_COLORS = [
    [8, 30, 100],       // 0: Deep Ocean — rich dark blue
    [15, 70, 160],      // 1: Ocean — vivid blue
    [240, 220, 160],    // 2: Beach — warm golden sand
    [245, 190, 70],     // 3: Desert — bold amber/orange
    [190, 210, 50],     // 4: Savanna — warm yellow-green
    [50, 200, 40],      // 5: Grassland — vivid bright green
    [20, 160, 35],      // 6: Forest — rich green
    [10, 100, 25],      // 7: Dense Forest — deep emerald
    [50, 120, 55],      // 8: Swamp — muted teal-green
    [170, 145, 120],    // 9: Mountain — warm sandstone
    [250, 250, 255],    // 10: Snow Peak — bright white
    [210, 235, 255],    // 11: Ice — pale blue-white
];

// ============================================================
// QUADTREE NODE — Pioneer-style split/merge logic
// ============================================================

/**
 * A node in the terrain quadtree. Each node can either be a leaf
 * (has a mesh) or a branch (has 4 children). Pioneer's terrain
 * uses this exact pattern — split when close, merge when far.
 */
export class QuadtreeNode {
    /**
     * @param {number} x - Center X in world units
     * @param {number} z - Center Z in world units
     * @param {number} size - Width/height of this node in world units
     * @param {number} depth - Quadtree depth (0 = root)
     * @param {QuadtreeNode|null} parent - Parent node
     */
    constructor(x, z, size, depth, parent = null) {
        this.x = x;
        this.z = z;
        this.size = size;
        this.depth = depth;
        this.parent = parent;

        // Children (null if leaf)
        this.children = null;

        // Mesh (null if branch)
        this.chunk = null;

        // Split state
        this.isSplit = false;
        this.splitDistance = size * TERRAIN_CONFIG.splitDistanceMultiplier * TERRAIN_CONFIG.lodBias;
        this.mergeDistance = this.splitDistance * TERRAIN_CONFIG.mergeHysteresis;
    }

    /**
     * Determine if this node should split (camera is close enough).
     * Pioneer uses distance-to-center with a size-proportional threshold.
     */
    shouldSplit(camX, camZ) {
        if (this.depth >= TERRAIN_CONFIG.maxQuadtreeDepth) return false;
        const dx = camX - this.x;
        const dz = camZ - this.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        return dist < this.splitDistance;
    }

    /**
     * Determine if this node should merge (camera is far enough).
     * Uses hysteresis to prevent oscillation.
     */
    shouldMerge(camX, camZ) {
        const dx = camX - this.x;
        const dz = camZ - this.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        return dist > this.mergeDistance;
    }

    /**
     * Check if camera is within the visible range for this node.
     */
    isVisible(camX, camZ, viewRadius) {
        const halfSize = this.size / 2;
        const maxDist = viewRadius + halfSize;
        const dx = Math.abs(camX - this.x);
        const dz = Math.abs(camZ - this.z);
        return dx < maxDist && dz < maxDist;
    }
}

// ============================================================
// TERRAIN CHUNK (single piece of terrain)
// ============================================================

export class TerrainChunkMesh {
    /**
     * @param {number} x - Chunk X in grid coordinates
     * @param {number} y - Chunk Y in grid coordinates
     * @param {number} depth - Quadtree depth (0 = root, max = most detailed)
     * @param {number} worldSize - Size of this chunk in world units
     */
    constructor(x, y, depth, worldSize) {
        this.x = x;
        this.y = y;
        this.depth = depth;
        this.worldSize = worldSize;
        this.key = `${depth}:${x}:${y}`;

        // State
        this.state = 'pending'; // pending | generating | ready | disposed
        this.mesh = null;
        this.geometry = null;
        this.material = null;

        // Data (filled by worker)
        this.elevation = null;
        this.moisture = null;
        this.biomeIds = null;

        // World position (center of chunk)
        this.worldX = x * worldSize;
        this.worldZ = y * worldSize;

        // LOD metrics
        this.lastDistanceToCamera = Infinity;

        // Fade-in: chunks start transparent and smoothly appear
        this.fadeProgress = 0; // 0 = invisible, 1 = fully opaque
        this.fadeSpeed = 3.0;  // Fully visible in ~0.33 seconds
    }

    /**
     * Build the 3D mesh from heightmap data.
     * Called after the WebWorker returns the chunk data.
     * @param {Object} chunkData - From WebWorker
     * @param {Object} config - TERRAIN_CONFIG
     * @param {THREE.Material} [pooledMaterial] - Reuse from pool
     */
    buildMesh(chunkData, config, pooledMaterial) {

        this.elevation = chunkData.elevation;
        this.moisture = chunkData.moisture;
        this.biomeIds = chunkData.biomeIds;

        // Data is now (res x res) = (33 x 33) — exactly matching PlaneGeometry vertex count.
        const dataRes = chunkData.chunkSize; // 33

        // Create plane geometry: 32 segments = 33 verts per edge
        const geo = new THREE.PlaneGeometry(
            this.worldSize,
            this.worldSize,
            dataRes - 1,
            dataRes - 1
        );
        geo.rotateX(-Math.PI / 2); // Make it horizontal

        const pos = geo.getAttribute('position');
        const vertCount = pos.count;
        const colors = new Float32Array(vertCount * 3);

        // PlaneGeometry lays out vertices row-by-row matching our data grid.
        // Direct 1:1 mapping — each vertex i maps to data[i].
        for (let i = 0; i < vertCount; i++) {
            const vx = pos.getX(i);
            const vz = pos.getZ(i);
            const elevation = this.elevation[i] || 0;

            // Height displacement — smooth rolling terrain (NMS-style)
            let height = 0;
            const wl = config.waterLevel;
            if (elevation > wl + 0.05) {
                // Above water: smooth Hermite curve for rolling hills (no sharp steps)
                const normalizedElev = (elevation - wl) / (1.0 - wl);
                // Smoothstep-inspired curve: gentle at low elevations, steeper for mountains
                const smoothElev = normalizedElev * normalizedElev * (3.0 - 2.0 * normalizedElev);
                height = smoothElev * config.heightScale;
                // Gradual extra lift for high peaks
                if (normalizedElev > 0.7) {
                    const peakFactor = (normalizedElev - 0.7) / 0.3; // 0-1 for peak range
                    height += peakFactor * peakFactor * config.heightScale * 0.2;
                }
            } else if (elevation > wl - 0.05) {
                // Beach/shoreline transition zone — smooth blend from water to land
                const t = (elevation - (wl - 0.05)) / 0.10; // 0-1 across transition
                const smoothT = t * t * (3 - 2 * t); // Hermite smoothstep
                height = smoothT * 0.3; // Gentle beach slope (0 to 0.3m)
            } else {
                // Below water: gentle ocean floor
                const depth = (wl - elevation) / wl;
                height = -0.3 - depth * 0.5; // -0.3 to -0.8m
            }

            pos.setY(i, height);

            // Biome color
            const biomeId = this.biomeIds[i] || 0;

            if (elevation <= config.waterLevel) {
                const depth = 1.0 - (elevation / Math.max(config.waterLevel, 0.001));
                colors[i * 3] = (10 + depth * 5) / 255;
                colors[i * 3 + 1] = (30 + depth * 15) / 255;
                colors[i * 3 + 2] = (80 + depth * 40) / 255;
            } else {
                const col = NMS_COLORS[biomeId] || [255, 0, 255];

                // Elevation-based brightness: lower = darker (fake AO in valleys)
                const elevFactor = 0.7 + elevation * 0.3;

                // Multi-octave color variation for NMS-style painterly terrain
                const wx = this.worldX + vx;
                const wz = this.worldZ + vz;

                // Low frequency: broad color patches
                const seed1 = hashSeed(Math.round(wx * 0.15), Math.round(wz * 0.15));
                const lo = ((seed1 & 0xFF) / 255 - 0.5) * 0.12;

                // Mid frequency: smaller splotches
                const seed2 = hashSeed(Math.round(wx * 0.5), Math.round(wz * 0.5));
                const mid = ((seed2 & 0xFF) / 255 - 0.5) * 0.08;

                // High frequency: micro detail
                const seed3 = hashSeed(Math.round(wx * 1.5), Math.round(wz * 1.5));
                const hi = ((seed3 & 0xFF) / 255 - 0.5) * 0.04;

                const variation = lo + mid + hi;

                // Slope darkening — steeper terrain gets darker (fake AO)
                const slopeDarken = (i > 0 && i < this.elevation.length - 1) ?
                    Math.abs(this.elevation[i] - this.elevation[Math.max(0, i - 1)]) * 2.0 : 0;
                const slopeFactor = Math.max(0.7, 1.0 - slopeDarken);

                // Per-channel color variation (slightly different per channel for richness)
                const seed4 = hashSeed(Math.round(wx * 0.8), Math.round(wz * 0.3));
                const rShift = ((seed4 & 0xFF) / 255 - 0.5) * 0.03;
                const gShift = (((seed4 >> 8) & 0xFF) / 255 - 0.5) * 0.03;

                const r = (col[0] / 255) * elevFactor * slopeFactor + variation + rShift;
                const g = (col[1] / 255) * elevFactor * slopeFactor + variation + gShift;
                const b = (col[2] / 255) * elevFactor * slopeFactor + variation;

                colors[i * 3] = Math.max(0, Math.min(1, r));
                colors[i * 3 + 1] = Math.max(0, Math.min(1, g));
                colors[i * 3 + 2] = Math.max(0, Math.min(1, b));
            }
        }

        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geo.computeVertexNormals();

        // Add skirt geometry to hide LOD cracks between chunks
        // Skirts extend downward from edge vertices, covering gaps at LOD transitions
        const skirtDepth = config.skirtDepth || 5.0;
        this._addSkirtGeometry(geo, dataRes, skirtDepth, colors);

        // NMS-style terrain material — PBR with slope darkening and detail noise
        // injected via onBeforeCompile for max compatibility with shadows/SSAO
        const mat = pooledMaterial || new THREE.MeshStandardMaterial({
            vertexColors: true,
            flatShading: false,
            roughness: 0.85,
            metalness: 0.02,
        });

        // Inject NMS-style enhancements into the standard material shader
        if (!mat._tgoPatched) {
            mat.onBeforeCompile = (shader) => {
                // Add uniforms for slope darkening + detail noise
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <common>',
                    `#include <common>
                    // NMS-style slope darkening: steep faces are darker (fake AO)
                    // Detail noise: subtle procedural texture to break up flat vertex colors
                    `
                );
                // After normal is available, darken steep slopes
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <dithering_fragment>',
                    `// Slope-based darkening (NMS-style fake AO on cliffs)
                    float slopeAngle = 1.0 - abs(dot(vNormal, vec3(0.0, 1.0, 0.0)));
                    float slopeDarken = mix(1.0, 0.6, smoothstep(0.3, 0.8, slopeAngle));
                    gl_FragColor.rgb *= slopeDarken;
                    #include <dithering_fragment>`
                );
            };
            mat._tgoPatched = true;
        }

        this.geometry = geo;
        this.material = mat;
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.set(this.worldX, 0, this.worldZ);

        // Terrain receives shadows from sun (flora/rocks cast)
        this.mesh.castShadow = false;
        this.mesh.receiveShadow = true;

        // Start faded out — will smoothly fade in via updateFade()
        this.fadeProgress = 0;
        mat.transparent = true;
        mat.opacity = 0;

        this.state = 'ready';
        return this.mesh;
    }

    /**
     * Get the height at a specific world position (for physics/walking).
     * Uses bilinear interpolation of the elevation data for smooth results.
     */
    getHeightAt(worldX, worldZ) {
        if (!this.elevation) return 0;

        const localX = worldX - (this.worldX - this.worldSize / 2);
        const localZ = worldZ - (this.worldZ - this.worldSize / 2);
        const u = localX / this.worldSize;
        const v = localZ / this.worldSize;

        if (u < 0 || u > 1 || v < 0 || v > 1) return null;

        const dataRes = Math.round(Math.sqrt(this.elevation.length));
        const gx = Math.min(Math.floor(u * (dataRes - 1)), dataRes - 2);
        const gy = Math.min(Math.floor(v * (dataRes - 1)), dataRes - 2);
        const fx = u * (dataRes - 1) - gx;
        const fy = v * (dataRes - 1) - gy;

        const e00 = this.elevation[gy * dataRes + gx] || 0;
        const e10 = this.elevation[gy * dataRes + gx + 1] || 0;
        const e01 = this.elevation[(gy + 1) * dataRes + gx] || 0;
        const e11 = this.elevation[(gy + 1) * dataRes + gx + 1] || 0;
        const elevation = e00 * (1 - fx) * (1 - fy) + e10 * fx * (1 - fy) +
                         e01 * (1 - fx) * fy + e11 * fx * fy;

        // Same height formula as buildMesh (MUST be kept in sync!)
        const wl = TERRAIN_CONFIG.waterLevel;
        let height = 0;
        if (elevation > wl + 0.05) {
            const normalizedElev = (elevation - wl) / (1.0 - wl);
            const smoothElev = normalizedElev * normalizedElev * (3.0 - 2.0 * normalizedElev);
            height = smoothElev * TERRAIN_CONFIG.heightScale;
            if (normalizedElev > 0.7) {
                const peakFactor = (normalizedElev - 0.7) / 0.3;
                height += peakFactor * peakFactor * TERRAIN_CONFIG.heightScale * 0.2;
            }
        } else if (elevation > wl - 0.05) {
            const t = (elevation - (wl - 0.05)) / 0.10;
            const smoothT = t * t * (3 - 2 * t);
            height = smoothT * 0.3;
        } else {
            const depth = (wl - elevation) / wl;
            height = -0.3 - depth * 0.5;
        }
        return height;
    }

    /**
     * Get the biome ID at a specific world position.
     * Uses bilinear interpolation of the 4 nearest biome samples,
     * picking the dominant one for a smooth boundary feel.
     */
    getBiomeAt(worldX, worldZ) {
        if (!this.biomeIds) return null;

        const localX = worldX - (this.worldX - this.worldSize / 2);
        const localZ = worldZ - (this.worldZ - this.worldSize / 2);
        const u = localX / this.worldSize;
        const v = localZ / this.worldSize;

        if (u < 0 || u > 1 || v < 0 || v > 1) return null;

        const dataRes = Math.round(Math.sqrt(this.biomeIds.length));
        const gx = Math.min(Math.floor(u * (dataRes - 1)), dataRes - 2);
        const gy = Math.min(Math.floor(v * (dataRes - 1)), dataRes - 2);

        // Return the biome at nearest grid point
        return this.biomeIds[gy * dataRes + gx];
    }

    /**
     * Add skirt geometry around chunk edges to hide LOD transition cracks.
     * Creates downward-extending triangles from edge vertices.
     */
    _addSkirtGeometry(geo, dataRes, skirtDepth, surfaceColors) {
        const pos = geo.getAttribute('position');
        const nrm = geo.getAttribute('normal');
        const idx = geo.getIndex();
        const oldVerts = pos.count;

        // Collect edge vertex indices (perimeter of the grid)
        const edgeIndices = [];
        for (let x = 0; x < dataRes; x++) {
            edgeIndices.push(x);                                   // Top edge
            edgeIndices.push((dataRes - 1) * dataRes + x);        // Bottom edge
        }
        for (let y = 1; y < dataRes - 1; y++) {
            edgeIndices.push(y * dataRes);                         // Left edge
            edgeIndices.push(y * dataRes + dataRes - 1);          // Right edge
        }

        // Create new arrays with skirt vertices appended
        const skirtCount = edgeIndices.length;
        const newVertCount = oldVerts + skirtCount;
        const newPositions = new Float32Array(newVertCount * 3);
        const newColors = new Float32Array(newVertCount * 3);
        const newNormals = new Float32Array(newVertCount * 3);

        // Copy existing data
        for (let i = 0; i < oldVerts * 3; i++) {
            newPositions[i] = pos.array[i];
            newColors[i] = surfaceColors[i];
            newNormals[i] = nrm ? nrm.array[i] : 0;
        }

        // Add skirt vertices (same XZ, Y dropped by skirtDepth)
        const skirtIndexMap = new Map(); // edgeVertexIndex -> newVertexIndex
        for (let i = 0; i < skirtCount; i++) {
            const ei = edgeIndices[i];
            const ni = oldVerts + i;
            newPositions[ni * 3]     = pos.getX(ei);
            newPositions[ni * 3 + 1] = pos.getY(ei) - skirtDepth;
            newPositions[ni * 3 + 2] = pos.getZ(ei);
            // Same color as surface vertex
            newColors[ni * 3]     = surfaceColors[ei * 3];
            newColors[ni * 3 + 1] = surfaceColors[ei * 3 + 1];
            newColors[ni * 3 + 2] = surfaceColors[ei * 3 + 2];
            // Copy normal from corresponding surface vertex (prevents black faces)
            if (nrm) {
                newNormals[ni * 3]     = nrm.getX(ei);
                newNormals[ni * 3 + 1] = nrm.getY(ei);
                newNormals[ni * 3 + 2] = nrm.getZ(ei);
            } else {
                newNormals[ni * 3 + 1] = 1; // Default up normal
            }
            skirtIndexMap.set(ei, ni);
        }

        // Build skirt triangles along each edge
        const skirtTriangles = [];

        // Helper: add skirt quad between two adjacent edge vertices
        const addSkirtQuad = (a, b) => {
            const sa = skirtIndexMap.get(a);
            const sb = skirtIndexMap.get(b);
            if (sa === undefined || sb === undefined) return;
            skirtTriangles.push(a, sa, b);
            skirtTriangles.push(b, sa, sb);
        };

        // Top edge (y=0 row)
        for (let x = 0; x < dataRes - 1; x++) addSkirtQuad(x, x + 1);
        // Bottom edge
        for (let x = 0; x < dataRes - 1; x++) {
            const base = (dataRes - 1) * dataRes;
            addSkirtQuad(base + x + 1, base + x); // Reversed winding
        }
        // Left edge
        for (let y = 0; y < dataRes - 1; y++) {
            addSkirtQuad((y + 1) * dataRes, y * dataRes);
        }
        // Right edge
        for (let y = 0; y < dataRes - 1; y++) {
            addSkirtQuad(y * dataRes + dataRes - 1, (y + 1) * dataRes + dataRes - 1);
        }

        // Merge with existing index buffer
        const oldIndices = idx ? Array.from(idx.array) : [];
        const newIndices = [...oldIndices, ...skirtTriangles];

        // Apply new geometry data (including normals for skirt vertices)
        geo.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(newColors, 3));
        geo.setAttribute('normal', new THREE.BufferAttribute(newNormals, 3));
        geo.setIndex(newIndices);
    }

    /**
     * Advance fade-in animation. Call each frame.
     * @param {number} dt - Delta time in seconds
     * @returns {boolean} True if still fading
     */
    updateFade(dt) {
        if (this.fadeProgress >= 1) return false;
        this.fadeProgress = Math.min(1, this.fadeProgress + dt * this.fadeSpeed);
        if (this.material) {
            this.material.opacity = this.fadeProgress;
            // Switch to opaque once fully faded in (better performance)
            if (this.fadeProgress >= 1) {
                this.material.transparent = false;
                this.material.opacity = 1;
            }
        }
        return this.fadeProgress < 1;
    }

    dispose() {
        if (this.geometry) this.geometry.dispose();
        if (this.material) this.material.dispose();
        this.mesh = null;
        this.state = 'disposed';
    }
}

// ============================================================
// TERRAIN MANAGER — Pioneer-style quadtree + worker orchestration
// ============================================================

// Reusable bounding box for frustum culling (avoids per-frame allocation)
const _chunkBox = new THREE.Box3();

export class TerrainManager {
    /**
     * @param {THREE.Scene} scene
     * @param {Object} planetData - { rule, seed, moistureRule }
     * @param {Object} [config] - Override TERRAIN_CONFIG
     */
    constructor(scene, planetData, config = {}) {
        this.scene = scene;
        this.planetData = planetData;
        this.config = { ...TERRAIN_CONFIG, ...config };

        // Active chunks (key -> TerrainChunkMesh)
        this.chunks = new Map();

        // Chunks being generated
        this.pendingChunks = new Map();

        // Web Worker (cache-bust to ensure latest version loads)
        this.worker = new Worker('./js/terrain/TerrainWorker.js?v=' + Date.now());
        this.worker.onmessage = (e) => this._onWorkerMessage(e);

        // Generation queue (priority queue by distance to camera)
        this.generationQueue = [];
        this._activeGenerations = 0;  // How many chunks are currently generating
        this._maxParallelGen = 4;     // Process up to 4 chunks at once

        // Stale chunks — old chunks kept visible until replacements are ready
        this._staleChunks = new Map();

        // Quadtree roots — grid of root-level nodes
        this.quadtreeRoots = new Map();

        // Water plane
        this.waterMesh = null;

        // Chunk pool — reuse disposed geometry/material objects
        this._chunkPool = [];

        // Frustum culling
        this._frustum = new THREE.Frustum();
        this._projScreenMatrix = new THREE.Matrix4();
        this._camera = null; // Set by update()

        // Adaptive LOD — auto-adjust lodBias based on FPS
        this._adaptiveLodBias = this.config.lodBias;
        this._fpsHistory = [];
        this._fpsHistoryMax = 30; // Track last 30 frames
        this._adaptiveTimer = 0;
        this._adaptiveInterval = 1.0; // Re-evaluate every second

        // Stats
        this.stats = {
            activeChunks: 0,
            pendingChunks: 0,
            totalTriangles: 0,
            maxDepth: 0,
            lodBias: this._adaptiveLodBias,
            culledChunks: 0,
        };
    }

    /**
     * Update terrain based on camera position.
     * Uses Pioneer-style quadtree: split close chunks, merge far ones.
     * @param {THREE.Vector3} cameraPosition
     * @param {THREE.Camera} [camera] - For frustum culling (optional)
     * @param {number} [dt] - Delta time for adaptive LOD (optional)
     */
    update(cameraPosition, camera, dt) {
        const camX = cameraPosition.x;
        const camZ = cameraPosition.z;

        // Update frustum for culling
        if (camera) {
            this._camera = camera;
            this._projScreenMatrix.multiplyMatrices(
                camera.projectionMatrix, camera.matrixWorldInverse
            );
            this._frustum.setFromProjectionMatrix(this._projScreenMatrix);
        }

        // Adaptive LOD — adjust bias based on FPS
        if (dt && dt > 0) {
            this._updateAdaptiveLOD(dt);
        }

        // Determine which chunks should exist via quadtree evaluation
        const desiredChunks = this._getDesiredChunks(camX, camZ);

        // Find new chunks to generate
        for (const [key, chunkInfo] of desiredChunks) {
            if (!this.chunks.has(key) && !this.pendingChunks.has(key)) {
                this._requestChunk(chunkInfo);
            }
        }

        // Move unneeded chunks to stale (keep visible as placeholders)
        // instead of removing immediately — prevents black holes
        let culledCount = 0;
        for (const [key, chunk] of this.chunks) {
            if (!desiredChunks.has(key)) {
                // Move to stale instead of removing — stays visible until area is covered
                this._staleChunks.set(key, chunk);
                this.chunks.delete(key);
            } else if (chunk.mesh && this._camera) {
                // Frustum culling — hide chunks outside camera view
                const halfSize = chunk.worldSize / 2;
                _chunkBox.min.set(chunk.worldX - halfSize, -5, chunk.worldZ - halfSize);
                _chunkBox.max.set(chunk.worldX + halfSize, this.config.heightScale + 20, chunk.worldZ + halfSize);
                const visible = this._frustum.intersectsBox(_chunkBox);
                chunk.mesh.visible = visible;
                if (!visible) culledCount++;
            }
        }

        // Clean up stale chunks whose area is now covered by active chunks
        this._cleanStaleChunks(camX, camZ);

        // Process generation queue (parallel)
        this._processQueue();

        // Update chunk fade-in animations
        if (dt && dt > 0) {
            for (const chunk of this.chunks.values()) {
                if (chunk.fadeProgress < 1) {
                    chunk.updateFade(dt);
                }
            }
        }

        // Update water plane position
        if (this.waterMesh) {
            this.waterMesh.position.set(camX, -0.3, camZ);
        }

        // Update stats
        this.stats.activeChunks = this.chunks.size;
        this.stats.pendingChunks = this.pendingChunks.size;
        this.stats.lodBias = this._adaptiveLodBias;
        this.stats.culledChunks = culledCount;
    }

    /**
     * Remove stale chunks once their area is covered by new active chunks,
     * or if they're very far from the camera. This prevents black holes
     * when moving — old terrain stays visible until new terrain loads.
     */
    _cleanStaleChunks(camX, camZ) {
        const maxStaleDist = this.config.chunkWorldSize * (this.config.viewRadius + 3);
        for (const [key, stale] of this._staleChunks) {
            // Always remove if very far from camera
            const dx = camX - stale.worldX;
            const dz = camZ - stale.worldZ;
            const dist = Math.sqrt(dx * dx + dz * dz);
            if (dist > maxStaleDist) {
                this._disposeStaleChunk(key);
                continue;
            }

            // Check if an active chunk now covers this stale chunk's area
            // AND is sufficiently faded in (visible enough to replace the stale chunk)
            let covered = false;
            for (const [, active] of this.chunks) {
                if (active.state !== 'ready' || !active.mesh) continue;
                if (active.fadeProgress < 0.5) continue; // Don't remove stale until replacement is visible
                const aHalf = active.worldSize / 2;
                const sHalf = stale.worldSize / 2;
                // Active chunk covers stale if it overlaps its center area
                if (stale.worldX >= active.worldX - aHalf && stale.worldX < active.worldX + aHalf &&
                    stale.worldZ >= active.worldZ - aHalf && stale.worldZ < active.worldZ + aHalf) {
                    covered = true;
                    break;
                }
            }
            if (covered) {
                this._disposeStaleChunk(key);
            }
        }
    }

    _disposeStaleChunk(key) {
        const chunk = this._staleChunks.get(key);
        if (chunk) {
            if (chunk.mesh) this.scene.remove(chunk.mesh);
            if (chunk.material && this._chunkPool.length < this.config.chunkPoolSize) {
                this._chunkPool.push(chunk.material);
                chunk.material = null;
            }
            chunk.dispose();
            this._staleChunks.delete(key);
        }
    }

    /**
     * Adaptive LOD — auto-adjust lodBias based on recent FPS.
     * When FPS drops below target, increase lodBias (less detail).
     * When FPS is comfortably above, decrease lodBias (more detail).
     */
    _updateAdaptiveLOD(dt) {
        const fps = 1.0 / Math.max(dt, 0.001);
        this._fpsHistory.push(fps);
        if (this._fpsHistory.length > this._fpsHistoryMax) {
            this._fpsHistory.shift();
        }

        this._adaptiveTimer += dt;
        if (this._adaptiveTimer < this._adaptiveInterval) return;
        this._adaptiveTimer = 0;

        if (this._fpsHistory.length < 10) return;

        // Use median FPS (more stable than mean)
        const sorted = [...this._fpsHistory].sort((a, b) => a - b);
        const medianFPS = sorted[Math.floor(sorted.length / 2)];
        const target = this.config.adaptiveTargetFPS;

        if (medianFPS < target - 5) {
            // FPS too low — reduce detail
            this._adaptiveLodBias = Math.min(
                this.config.adaptiveLodMax,
                this._adaptiveLodBias + 0.1
            );
        } else if (medianFPS > target + 5) {
            // FPS high — increase detail
            this._adaptiveLodBias = Math.max(
                this.config.adaptiveLodMin,
                this._adaptiveLodBias - 0.05
            );
        }
    }

    /**
     * Pioneer-style quadtree chunk selection.
     *
     * For each potential root chunk in view range, recursively decide:
     * - If camera is close enough → SPLIT into 4 children
     * - If camera is far enough → this chunk is a LEAF (render it)
     *
     * This gives us high detail nearby and coarse detail far away,
     * exactly like Pioneer's planetary terrain.
     */
    _getDesiredChunks(camX, camZ) {
        const desired = new Map();
        const chunkSize = this.config.chunkWorldSize;
        const radius = this.config.viewRadius || 8;

        // Camera position in chunk grid coordinates
        const gridCamX = Math.floor(camX / chunkSize);
        const gridCamZ = Math.floor(camZ / chunkSize);

        for (let dx = -radius; dx <= radius; dx++) {
            for (let dz = -radius; dz <= radius; dz++) {
                // Circular view distance (not square)
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist > radius) continue;

                const cx = gridCamX + dx;
                const cz = gridCamZ + dz;

                // Evaluate quadtree for this root chunk
                this._evaluateQuadtreeNode(
                    cx * chunkSize, // world center X
                    cz * chunkSize, // world center Z
                    chunkSize,      // size at this level
                    0,              // depth
                    cx, cz,         // grid coords
                    camX, camZ,     // camera position
                    desired
                );
            }
        }

        return desired;
    }

    /**
     * Recursively evaluate a quadtree node.
     * If close enough to camera and not at max depth, split into 4 children.
     * Otherwise, add this node as a leaf chunk to render.
     */
    _evaluateQuadtreeNode(worldX, worldZ, size, depth, gridX, gridZ, camX, camZ, desired) {
        // Distance from camera to chunk center
        const dx = camX - worldX;
        const dz = camZ - worldZ;
        const dist = Math.sqrt(dx * dx + dz * dz);

        // Pioneer's split criterion: split if camera is within (size * multiplier)
        // Uses adaptive LOD bias for FPS-driven quality adjustment
        const splitDist = size * this.config.splitDistanceMultiplier * this._adaptiveLodBias;
        const shouldSplit = depth < this.config.maxQuadtreeDepth && dist < splitDist;

        if (shouldSplit) {
            // Split into 4 children
            const halfSize = size / 2;
            const quarterSize = size / 4;
            const childDepth = depth + 1;

            // NW, NE, SW, SE children
            const offsets = [
                [-quarterSize, -quarterSize],
                [+quarterSize, -quarterSize],
                [-quarterSize, +quarterSize],
                [+quarterSize, +quarterSize],
            ];

            for (let i = 0; i < 4; i++) {
                const childX = worldX + offsets[i][0];
                const childZ = worldZ + offsets[i][1];
                // Child grid coords encode both parent position and quadrant
                const childGridX = gridX * 2 + (i & 1);
                const childGridZ = gridZ * 2 + ((i >> 1) & 1);

                this._evaluateQuadtreeNode(
                    childX, childZ,
                    halfSize, childDepth,
                    childGridX, childGridZ,
                    camX, camZ,
                    desired
                );
            }
        } else {
            // This is a leaf — render it
            const key = `${depth}:${gridX}:${gridZ}`;
            desired.set(key, {
                x: gridX,
                y: gridZ,
                depth,
                worldSize: size,
                worldX,
                worldZ,
                distance: dist,
            });

            // Track max depth for stats
            if (depth > this.stats.maxDepth) {
                this.stats.maxDepth = depth;
            }
        }
    }

    /**
     * Queue a chunk for generation by the WebWorker.
     */
    _requestChunk(chunkInfo) {
        const { x, y, depth, worldSize, worldX, worldZ, distance } = chunkInfo;
        const key = `${depth}:${x}:${y}`;

        const chunk = new TerrainChunkMesh(x, y, depth, worldSize);
        // Override world position for quadtree children
        if (worldX !== undefined) {
            chunk.worldX = worldX;
            chunk.worldZ = worldZ;
        }
        chunk.state = 'queued';
        this.pendingChunks.set(key, chunk);

        this.generationQueue.push({
            key,
            chunk,
            distance,
            params: {
                type: 'generateChunk',
                chunkX: x,
                chunkY: y,
                chunkSize: this.config.chunkResolution - 1,
                rule: this.planetData.rule,
                seed: this.planetData.seed,
                moistureRule: this.planetData.moistureRule || ((this.planetData.rule + 73) & 0xFF),
                // Pass LOD depth so worker can adjust generation
                lodDepth: depth,
                worldSize: worldSize,
                // World coordinates for consistent noise across all LOD levels
                worldX: chunk.worldX,
                worldZ: chunk.worldZ,
                // Chunk key for reliable matching on response
                key: key,
            }
        });

        // Sort by distance (closest first)
        this.generationQueue.sort((a, b) => a.distance - b.distance);
    }

    /**
     * Process the generation queue — send multiple chunks in parallel.
     * Worker handles them sequentially but the messages queue up,
     * eliminating round-trip latency between chunks.
     */
    _processQueue() {
        while (this._activeGenerations < this._maxParallelGen && this.generationQueue.length > 0) {
            const job = this.generationQueue.shift();
            if (!job) break;

            // Check if still needed
            if (job.chunk.state === 'disposed') {
                continue; // Skip disposed, try next
            }

            this._activeGenerations++;
            job.chunk.state = 'generating';
            this.worker.postMessage(job.params);
        }
    }

    /**
     * Handle completed chunk from WebWorker.
     */
    _onWorkerMessage(e) {
        const data = e.data;
        if (data.type !== 'chunkReady') return;

        this._activeGenerations = Math.max(0, this._activeGenerations - 1);

        // Match by key (exact depth:x:y) for reliable identification
        const matchKey = data.key;
        const chunk = matchKey ? this.pendingChunks.get(matchKey) : null;

        if (!chunk || chunk.state !== 'generating') {
            // Chunk was removed while generating — discard
            this._processQueue();
            return;
        }

        this.pendingChunks.delete(matchKey);

        // Build the 3D mesh (try pooled material first)
        const pooledMat = this._getPooledMaterial();
        const mesh = chunk.buildMesh(data, this.config, pooledMat);
        if (mesh) {
            this.scene.add(mesh);
            this.chunks.set(matchKey, chunk);
        }

        // Continue processing queue
        this._processQueue();
    }

    /**
     * Remove a chunk from the scene.
     * Pools geometry/material for reuse instead of GC.
     */
    _removeChunk(key) {
        const chunk = this.chunks.get(key);
        if (chunk) {
            if (chunk.mesh) this.scene.remove(chunk.mesh);
            // Pool reusable material (geometry varies per chunk so dispose it)
            if (chunk.material && this._chunkPool.length < this.config.chunkPoolSize) {
                this._chunkPool.push(chunk.material);
                chunk.material = null; // Prevent dispose
            }
            chunk.dispose();
            this.chunks.delete(key);
        }

        // Also remove from pending if still waiting
        const pending = this.pendingChunks.get(key);
        if (pending) {
            pending.state = 'disposed';
            this.pendingChunks.delete(key);
        }
    }

    /**
     * Create the water plane with animated wave shader.
     * NMS-style: semi-transparent, subtle waves, Fresnel reflections.
     * @param {THREE.Color} [fogColor] - Fog color for blending
     * @param {THREE.Vector3} [sunDirection] - Sun direction for specular
     */
    createWater(fogColor, sunDirection) {
        const size = this.config.chunkWorldSize * 20; // Large enough to cover view
        const segments = 64; // Enough for visible wave displacement
        const geo = new THREE.PlaneGeometry(size, size, segments, segments);
        geo.rotateX(-Math.PI / 2);

        const mat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0.0 },
                uWaterColor: { value: new THREE.Color(0x0a3060) },
                uDeepColor: { value: new THREE.Color(0x020c1f) },
                uFogColor: { value: fogColor || new THREE.Color(0x88aacc) },
                uFogDensity: { value: 0.0025 },
                uSunDirection: { value: sunDirection || new THREE.Vector3(0.5, 0.3, 0.4).normalize() },
                uSunColor: { value: new THREE.Color(0xffeedd) },
                uCameraPos: { value: new THREE.Vector3() },
            },
            vertexShader: /* glsl */ `
                uniform float uTime;
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying float vFogDepth;

                void main() {
                    vec3 pos = position;

                    // Layered sine waves for organic water motion
                    float wave1 = sin(pos.x * 0.08 + uTime * 0.8) * 0.15;
                    float wave2 = sin(pos.z * 0.06 + uTime * 0.6 + 1.0) * 0.12;
                    float wave3 = sin((pos.x + pos.z) * 0.12 + uTime * 1.2) * 0.08;
                    float wave4 = sin(pos.x * 0.25 + pos.z * 0.18 + uTime * 1.5) * 0.04;
                    pos.y += wave1 + wave2 + wave3 + wave4;

                    // Compute normal from wave derivatives
                    float dx = cos(pos.x * 0.08 + uTime * 0.8) * 0.08 * 0.15
                             + cos((pos.x + pos.z) * 0.12 + uTime * 1.2) * 0.12 * 0.08
                             + cos(pos.x * 0.25 + pos.z * 0.18 + uTime * 1.5) * 0.25 * 0.04;
                    float dz = cos(pos.z * 0.06 + uTime * 0.6 + 1.0) * 0.06 * 0.12
                             + cos((pos.x + pos.z) * 0.12 + uTime * 1.2) * 0.12 * 0.08
                             + cos(pos.x * 0.25 + pos.z * 0.18 + uTime * 1.5) * 0.18 * 0.04;

                    vNormal = normalize(vec3(-dx, 1.0, -dz));

                    vec4 worldPos = modelMatrix * vec4(pos, 1.0);
                    vWorldPosition = worldPos.xyz;

                    vec4 mvPosition = viewMatrix * worldPos;
                    vFogDepth = length(mvPosition.xyz);

                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: /* glsl */ `
                uniform vec3 uWaterColor;
                uniform vec3 uDeepColor;
                uniform vec3 uFogColor;
                uniform float uFogDensity;
                uniform vec3 uSunDirection;
                uniform vec3 uSunColor;
                uniform vec3 uCameraPos;
                uniform float uTime;

                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying float vFogDepth;

                // ---- Procedural noise for shore foam ----
                float hash(vec2 p) {
                    float h = dot(p, vec2(127.1, 311.7));
                    return fract(sin(h) * 43758.5453123);
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                }

                float fbm(vec2 p) {
                    float v = 0.0;
                    float a = 0.5;
                    for (int i = 0; i < 4; i++) {
                        v += a * noise(p);
                        p *= 2.0;
                        a *= 0.5;
                    }
                    return v;
                }
                // ---- End noise ----

                void main() {
                    vec3 viewDir = normalize(uCameraPos - vWorldPosition);
                    vec3 normal = normalize(vNormal);

                    // Fresnel effect — more reflective at shallow angles
                    float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);
                    fresnel = 0.3 + 0.7 * fresnel;

                    // Depth-based coloring
                    float distFromCenter = length(vWorldPosition.xz - uCameraPos.xz);
                    vec3 shallowColor = vec3(0.1, 0.45, 0.5);
                    float shallowFactor = smoothstep(80.0, 10.0, distFromCenter) * 0.4;
                    vec3 baseWater = mix(uWaterColor, shallowColor, shallowFactor);

                    vec3 waterCol = mix(uDeepColor, baseWater, fresnel);

                    // Specular highlight from sun
                    vec3 halfDir = normalize(uSunDirection + viewDir);
                    float spec = pow(max(dot(normal, halfDir), 0.0), 128.0);
                    vec3 specular = uSunColor * spec * 0.8;

                    // Broad sun reflection
                    float broadSpec = pow(max(dot(normal, halfDir), 0.0), 8.0);
                    vec3 broadReflection = uSunColor * broadSpec * 0.15;

                    // Ripple highlights
                    float ripple = sin(vWorldPosition.x * 0.5 + vWorldPosition.z * 0.3 + uTime * 2.0);
                    float rippleHighlight = smoothstep(0.85, 1.0, ripple) * 0.1;

                    // Shore foam
                    vec2 foamUV = vWorldPosition.xz * 0.15;
                    float foamNoise = fbm(foamUV + uTime * vec2(0.05, 0.03));
                    float foamNoise2 = fbm(foamUV * 2.5 + uTime * vec2(-0.03, 0.07) + 50.0);

                    float waveHeight = normal.y;
                    float crestFoam = smoothstep(0.92, 0.98, waveHeight) * foamNoise * 0.6;
                    float shoreFoam = shallowFactor * smoothstep(0.4, 0.7, foamNoise2) * 0.5;
                    float totalFoam = max(crestFoam, shoreFoam);
                    vec3 foamColor = vec3(0.9, 0.95, 1.0);
                    waterCol = mix(waterCol, foamColor, totalFoam);

                    vec3 color = waterCol + specular + broadReflection;
                    color += vec3(rippleHighlight);

                    // Fog
                    float fogFactor = 1.0 - exp(-uFogDensity * uFogDensity * vFogDepth * vFogDepth);
                    fogFactor = clamp(fogFactor, 0.0, 1.0);
                    color = mix(color, uFogColor, fogFactor);

                    float distFade = smoothstep(500.0, 300.0, vFogDepth);

                    gl_FragColor = vec4(color, 0.85 * distFade);
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide,
            fog: false,
        });

        this.waterMesh = new THREE.Mesh(geo, mat);
        this.waterMesh.position.y = -0.1;
        this.waterMaterial = mat;
        this.scene.add(this.waterMesh);

        return this.waterMesh;
    }

    /**
     * Update water uniforms (call each frame).
     */
    updateWater(time, cameraPosition) {
        if (!this.waterMaterial) return;
        this.waterMaterial.uniforms.uTime.value = time;
        if (cameraPosition) {
            this.waterMaterial.uniforms.uCameraPos.value.copy(cameraPosition);
            if (this.waterMesh) {
                this.waterMesh.position.x = cameraPosition.x;
                this.waterMesh.position.z = cameraPosition.z;
            }
        }
    }

    /**
     * Get terrain height at a world position.
     * Queries the chunk that contains this position.
     * Prefers highest-LOD chunk when overlapping.
     */
    getHeightAt(worldX, worldZ) {
        let bestChunk = null;
        let bestDepth = -1;

        for (const [key, chunk] of this.chunks) {
            if (chunk.state !== 'ready') continue;

            const halfSize = chunk.worldSize / 2;
            if (worldX >= chunk.worldX - halfSize && worldX < chunk.worldX + halfSize &&
                worldZ >= chunk.worldZ - halfSize && worldZ < chunk.worldZ + halfSize) {
                if (chunk.depth > bestDepth) {
                    bestChunk = chunk;
                    bestDepth = chunk.depth;
                }
            }
        }
        return bestChunk ? bestChunk.getHeightAt(worldX, worldZ) : null;
    }

    /**
     * Get biome ID at a world position.
     * Used by creature system for biome-aware spawning.
     */
    getBiomeAt(worldX, worldZ) {
        let bestChunk = null;
        let bestDepth = -1;

        for (const [key, chunk] of this.chunks) {
            if (chunk.state !== 'ready') continue;

            const halfSize = chunk.worldSize / 2;
            if (worldX >= chunk.worldX - halfSize && worldX < chunk.worldX + halfSize &&
                worldZ >= chunk.worldZ - halfSize && worldZ < chunk.worldZ + halfSize) {
                if (chunk.depth > bestDepth) {
                    bestChunk = chunk;
                    bestDepth = chunk.depth;
                }
            }
        }
        return bestChunk ? bestChunk.getBiomeAt(worldX, worldZ) : null;
    }

    /**
     * Get a pooled material or create a new one.
     */
    _getPooledMaterial() {
        if (this._chunkPool.length > 0) {
            return this._chunkPool.pop();
        }
        return null;
    }

    /**
     * Get stats for HUD display.
     */
    getStats() {
        let totalTris = 0;
        for (const chunk of this.chunks.values()) {
            if (chunk.mesh && chunk.geometry) {
                const idx = chunk.geometry.index;
                totalTris += idx ? idx.count / 3 : chunk.geometry.getAttribute('position').count / 3;
            }
        }
        this.stats.totalTriangles = totalTris;
        return this.stats;
    }

    /**
     * Dispose everything.
     */
    dispose() {
        for (const chunk of this.chunks.values()) {
            if (chunk.mesh) this.scene.remove(chunk.mesh);
            chunk.dispose();
        }
        this.chunks.clear();
        // Clean up stale chunks too
        for (const [key] of this._staleChunks) {
            this._disposeStaleChunk(key);
        }
        this._staleChunks.clear();
        this.pendingChunks.clear();
        this.generationQueue = [];

        // Dispose pooled materials
        for (const mat of this._chunkPool) {
            mat.dispose();
        }
        this._chunkPool = [];

        if (this.waterMesh) {
            this.scene.remove(this.waterMesh);
            this.waterMesh.geometry.dispose();
            this.waterMesh.material.dispose();
        }

        this.worker.terminate();
    }
}
