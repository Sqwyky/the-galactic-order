<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Galactic Order - Planetary Landing</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        #game-canvas { display: block; width: 100vw; height: 100vh; }

        /* Atmosphere overlay — gets more opaque as we descend */
        #atmos-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* Vignette — now handled by GPU post-processing shader */
        /* CSS overlay removed to avoid double-vignette */

        /* HUD */
        #hud {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        /* Planet name banner */
        #planet-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: opacity 1.5s;
        }
        #planet-banner.visible { opacity: 1; }
        #planet-banner h1 {
            color: #fff;
            font-size: 36px;
            letter-spacing: 12px;
            text-shadow: 0 0 30px rgba(0,200,255,0.3);
            font-weight: 300;
        }
        #planet-banner .subtitle {
            color: #556;
            font-size: 12px;
            letter-spacing: 4px;
            margin-top: 8px;
        }

        /* Altitude HUD */
        #altitude-hud {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        #altitude-hud .altitude {
            color: #00ff88;
            font-size: 24px;
            letter-spacing: 3px;
        }
        #altitude-hud .label {
            color: #445;
            font-size: 10px;
            letter-spacing: 2px;
            margin-top: 4px;
        }

        /* Status bar */
        #status-bar {
            position: absolute;
            top: 16px;
            left: 16px;
        }
        #status-bar .phase {
            color: #00ff88;
            font-size: 12px;
            letter-spacing: 3px;
        }
        #status-bar .info {
            color: #334;
            font-size: 10px;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        /* Controls hint */
        #controls-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0;
            transition: opacity 1s;
        }
        #controls-hint.visible { opacity: 1; }
        #controls-hint .key {
            display: inline-block;
            border: 1px solid rgba(0,255,136,0.3);
            color: #00ff88;
            padding: 3px 8px;
            font-size: 10px;
            margin: 0 2px;
            letter-spacing: 1px;
        }
        #controls-hint .desc {
            color: #445;
            font-size: 10px;
            margin-top: 6px;
        }

        /* Perf */
        #perf {
            position: absolute;
            top: 16px;
            right: 16px;
            color: #333;
            font-size: 10px;
            text-align: right;
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 20px; height: 20px;
            pointer-events: none;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #crosshair.visible { opacity: 0.5; }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
        }
        #crosshair::before {
            width: 1px; height: 100%;
            left: 50%; top: 0;
        }
        #crosshair::after {
            width: 100%; height: 1px;
            top: 50%; left: 0;
        }

        /* Ship Summon Menu */
        #ship-menu {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            pointer-events: all;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        #ship-menu.visible {
            opacity: 1;
            visibility: visible;
        }
        #ship-menu .menu-title {
            color: #00ff88;
            font-size: 12px;
            letter-spacing: 4px;
            text-align: center;
            margin-bottom: 16px;
        }
        #ship-menu .menu-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        #ship-menu .menu-item {
            background: rgba(0, 30, 20, 0.85);
            border: 1px solid rgba(0, 255, 136, 0.25);
            color: #aaddcc;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            letter-spacing: 2px;
            padding: 10px 32px;
            cursor: pointer;
            width: 260px;
            text-align: center;
            transition: all 0.2s;
        }
        #ship-menu .menu-item:hover {
            background: rgba(0, 60, 40, 0.9);
            border-color: rgba(0, 255, 136, 0.6);
            color: #00ff88;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.4);
        }
        #ship-menu .menu-item .item-desc {
            color: #445;
            font-size: 9px;
            letter-spacing: 1px;
            margin-top: 4px;
        }
        #ship-menu .menu-close {
            color: #445;
            font-size: 10px;
            text-align: center;
            margin-top: 12px;
            letter-spacing: 2px;
        }

        /* Loading */
        #loading {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 2s;
        }
        #loading.fade { opacity: 0; pointer-events: none; }
        #loading h2 {
            color: #00ff88;
            font-size: 14px;
            letter-spacing: 6px;
        }
        #loading .bar { width: 300px; height: 2px; background: #111; margin-top: 20px; }
        #loading .bar-fill { height: 100%; background: #00ff88; width: 0%; transition: width 0.3s; }
        #loading .status { color: #444; font-size: 11px; margin-top: 12px; }

        /* Scan lines removed — was adding fuzzy pixel noise */
    </style>
</head>
<body>

<canvas id="game-canvas"></canvas>
<!-- vignette moved to GPU post-processing -->
<!-- scanlines removed -->
<div id="atmos-overlay"></div>
<div id="crosshair"></div>

<div id="hud">
    <div id="planet-banner">
        <h1 id="bannerName">PLANET</h1>
        <div class="subtitle" id="bannerSubtitle"></div>
    </div>

    <div id="altitude-hud">
        <div class="altitude" id="altitudeValue">---</div>
        <div class="label">ALTITUDE</div>
    </div>

    <div id="status-bar">
        <div class="phase" id="phaseName">ATMOSPHERIC ENTRY</div>
        <div class="info" id="phaseInfo"></div>
    </div>

    <div id="controls-hint">
        <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span>
        <span class="key">SHIFT</span>
        <span class="key">SPACE</span>
        <span class="key">E</span>
        <span class="key">X</span>
        <div class="desc">MOVE · SPRINT · JUMP · BOARD SHIP · SUMMON SHIP — CLICK TO MINE/LOOK</div>
    </div>

    <div id="perf"></div>
</div>

<div id="ship-menu">
    <div class="menu-title">SHIP COMMAND</div>
    <div class="menu-items">
        <div class="menu-item" id="menu-summon-ship">
            SUMMON SHIP
            <div class="item-desc">Call your ship to your location</div>
        </div>
        <div class="menu-item" id="menu-board-ship">
            BOARD SHIP
            <div class="item-desc">Teleport to and enter your ship</div>
        </div>
        <div class="menu-item" id="menu-ship-status">
            SHIP STATUS
            <div class="item-desc">Voidmoth Mk-I · Systems nominal</div>
        </div>
    </div>
    <div class="menu-close">[ X ] CLOSE</div>
</div>

<div id="loading">
    <h2>ATMOSPHERIC ENTRY</h2>
    <div class="bar"><div class="bar-fill" id="loadingBar"></div></div>
    <div class="status" id="loadingStatus">Calculating descent vector...</div>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { TerrainManager, TERRAIN_CONFIG } from './js/terrain/TerrainChunk.js';
import { WalkingController } from './js/terrain/WalkingController.js';
import { hashSeed } from './js/generation/hashSeed.js';
import { classifyRule } from './js/generation/cellularAutomata.js';
import { generatePlanetName } from './js/generation/nameGenerator.js';
import { NPCManager } from './js/npc/NPCManager.js';
import { DialogueSystem } from './js/ui/DialogueSystem.js';
import { TabletUI } from './js/ui/TabletUI.js';
import { SkyDome } from './js/rendering/SkyDome.js';
import { GrassSystem } from './js/terrain/GrassSystem.js';
import { RockScatter } from './js/terrain/RockScatter.js';
import { AtmosphericParticles } from './js/rendering/AtmosphericParticles.js';
import { AlienFloraSystem } from './js/terrain/AlienFlora.js';
import { derivePlanetMood, derivePlanetFrequency, frequencyToNote } from './js/generation/harmonicResonance.js';

// Ship systems
import { ShipModel } from './js/ship/ShipModel.js';
import { FlightController } from './js/ship/FlightController.js';
import { WeaponSystem } from './js/ship/WeaponSystem.js';
import { ScannerSystem } from './js/ship/ScannerSystem.js';
import { HyperspaceSystem } from './js/ship/HyperspaceSystem.js';
import { ShipHUD } from './js/ui/ShipHUD.js';

// Mining & Crafting systems
import { MiningSystem } from './js/terrain/MiningSystem.js';
import { InventoryManager } from './js/ui/InventoryManager.js';
import { MiningHUD } from './js/ui/MiningHUD.js';
import { ELEMENTS } from './js/generation/HarmonicElements.js';
import { PerformanceManager } from './js/rendering/PerformanceManager.js';

// Creature system
import { CreatureSystem } from './js/creatures/CreatureSystem.js';

// Galaxy navigation
import { GalaxyMap } from './js/ui/GalaxyMap.js';
import { SystemView } from './js/ui/SystemView.js';

// Audio
import { AudioManager } from './js/audio/AudioManager.js';

// First-person view model
import { FPSViewModel } from './js/ui/FPSViewModel.js';

// Day/Night cycle
import { DayNightCycle } from './js/rendering/DayNightCycle.js';

// Survival stats
import { SurvivalStats } from './js/ui/SurvivalStats.js';

// Post-processing imports
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
import { RayMarchedAtmospherePass } from './js/rendering/RayMarchedAtmosphere.js';

// ============================================================
// URL PARAMS — planet identity
// ============================================================
const params = new URLSearchParams(window.location.search);
let planetRule = parseInt(params.get('rule')) || 30;
let planetSeed = parseInt(params.get('seed')) || 42;
let planetName = params.get('name') || generatePlanetName(hashSeed(planetSeed, 'planet', 0));
const initialSystemX = parseInt(params.get('sx')) || 0;
const initialSystemY = parseInt(params.get('sy')) || 0;

// ============================================================
// LOADING
// ============================================================
const loadingEl = document.getElementById('loading');
const loadingBar = document.getElementById('loadingBar');
const loadingStatus = document.getElementById('loadingStatus');
function setLoading(pct, msg) {
    loadingBar.style.width = pct + '%';
    loadingStatus.textContent = msg;
}

// ============================================================
// LANDING PHASES
// ============================================================
const PHASE = {
    DESCENT: 'descent',       // Flying down through atmosphere
    LANDING: 'landing',       // Final approach to ground
    SURFACE: 'surface',       // Walking on the surface
    FLIGHT: 'flight',         // Flying ship
    GALAXY_MAP: 'galaxy_map', // Choosing a star system
    SYSTEM_VIEW: 'system_view', // Choosing a planet in a system
};
let currentPhase = PHASE.DESCENT;

// ============================================================
// RENDERER
// ============================================================
setLoading(10, 'Creating renderer...');
console.log('[TGO] Init: Creating renderer...');
const canvas = document.getElementById('game-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
// Soft shadow maps — controlled by performance tier (disabled on LOW/POTATO)
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

// ============================================================
// POST-PROCESSING — the NMS "cinematic painted sci-fi" look
// ============================================================
// Standard EffectComposer — attach depth textures for ray-marched atmosphere
console.log('[TGO] Init: Creating EffectComposer...');
const composer = new EffectComposer(renderer);
try {
    const depthTex1 = new THREE.DepthTexture();
    depthTex1.format = THREE.DepthFormat;
    depthTex1.type = THREE.UnsignedIntType;
    composer.renderTarget1.depthTexture = depthTex1;
    const depthTex2 = new THREE.DepthTexture();
    depthTex2.format = THREE.DepthFormat;
    depthTex2.type = THREE.UnsignedIntType;
    composer.renderTarget2.depthTexture = depthTex2;
} catch (e) {
    console.warn('[TGO] Depth texture setup failed:', e.message);
}

// Color Grading shader — cinematic NMS look: S-curve contrast, split toning,
// chromatic aberration, vignette, subtle warm/cool shift
const colorGradeShader = {
    uniforms: {
        tDiffuse: { value: null },
        uSaturation: { value: 1.3 },
        uContrast: { value: 1.12 },
        uBrightness: { value: 0.01 },
        uVignetteStrength: { value: 0.45 },
        uChromaticAberration: { value: 0.003 },
    },
    vertexShader: /* glsl */ `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */ `
        uniform sampler2D tDiffuse;
        uniform float uSaturation;
        uniform float uContrast;
        uniform float uBrightness;
        uniform float uVignetteStrength;
        uniform float uChromaticAberration;
        varying vec2 vUv;

        // Filmic S-curve tone map (more cinematic than linear contrast)
        vec3 sCurve(vec3 x) {
            return x * x * (3.0 - 2.0 * x);
        }

        void main() {
            // Radial chromatic aberration — stronger at screen edges
            vec2 center = vUv - 0.5;
            float edgeDist = length(center);
            vec2 dir = center * uChromaticAberration * (1.0 + edgeDist * 2.0);
            float r = texture2D(tDiffuse, vUv + dir).r;
            float g = texture2D(tDiffuse, vUv).g;
            float b = texture2D(tDiffuse, vUv - dir).b;
            vec3 color = vec3(r, g, b);

            // Saturation boost (NMS vivid palette)
            float luma = dot(color, vec3(0.299, 0.587, 0.114));
            color = mix(vec3(luma), color, uSaturation);

            // S-curve contrast (smooth, filmic — lifts shadows, compresses highlights)
            color = clamp(color, 0.0, 1.0);
            color = mix(color, sCurve(color), uContrast - 1.0 + 0.4);
            color += uBrightness;

            // Split toning — warm highlights (gold), cool shadows (blue)
            vec3 warmTint  = vec3(1.02, 0.98, 0.92);  // Subtle gold
            vec3 coolTint  = vec3(0.92, 0.95, 1.05);  // Subtle blue
            float lumaSplit = dot(color, vec3(0.299, 0.587, 0.114));
            vec3 tint = mix(coolTint, warmTint, smoothstep(0.25, 0.75, lumaSplit));
            color *= tint;

            // Vignette — smooth elliptical falloff, cinematic
            float vigDist = length(center * vec2(1.1, 1.0));
            float vig = smoothstep(0.3, 1.1, vigDist) * uVignetteStrength;
            vig += smoothstep(0.6, 1.3, vigDist) * uVignetteStrength * 0.3; // Extra darkening at corners
            color *= 1.0 - vig;

            gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
        }
    `
};

// Film Grain shader — dual-frequency grain for photographic 70s sci-fi texture
const filmGrainShader = {
    uniforms: {
        tDiffuse: { value: null },
        uTime: { value: 0.0 },
        uIntensity: { value: 0.025 },
    },
    vertexShader: /* glsl */ `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */ `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uIntensity;
        varying vec2 vUv;

        float hash(vec2 p) {
            float h = dot(p, vec2(127.1, 311.7));
            return fract(sin(h) * 43758.5453123);
        }
        float hash2(vec2 p) {
            float h = dot(p, vec2(269.5, 183.3));
            return fract(sin(h) * 28786.3157832);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            // Dual-frequency grain — fine + coarse for photographic feel
            float fineGrain  = hash(vUv * 1200.0 + uTime * 137.0) * 2.0 - 1.0;
            float coarseGrain = hash2(vUv * 300.0 + uTime * 89.0) * 2.0 - 1.0;
            float grain = fineGrain * 0.7 + coarseGrain * 0.3;

            // Grain is stronger in shadows (real film response)
            float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114));
            float grainStrength = uIntensity * (1.2 - luma * 0.6);

            // Subtle color grain — each channel gets slightly different noise
            float rGrain = grain + hash(vUv * 800.0 + uTime * 51.0) * 0.15;
            float bGrain = grain + hash2(vUv * 900.0 + uTime * 73.0) * 0.15;

            color.r += rGrain * grainStrength;
            color.g += grain * grainStrength;
            color.b += bGrain * grainStrength;

            gl_FragColor = color;
        }
    `
};
const filmGrainPass = new ShaderPass(filmGrainShader);

const scene = new THREE.Scene();

// ============================================================
// ATMOSPHERE / SKY
// ============================================================
console.log('[TGO] Init: Composer ready, generating atmosphere...');
setLoading(15, 'Generating atmosphere...');

// Determine atmosphere from Harmonic Resonance system (Antigravity Brain integration)
// The planet's CA rule → brainwave frequency → mood → sky colors, fog, atmosphere
let classification = classifyRule(planetRule);
let planetMood = derivePlanetMood(planetRule, planetSeed);
let planetFreq = derivePlanetFrequency(planetRule, planetSeed);
let planetNote = frequencyToNote(planetFreq.frequency);

// Sky colors driven by the planet's resonant frequency band
const skyTopColor = new THREE.Color(...planetMood.sky.topColor);
const skyBottomColor = new THREE.Color(...planetMood.sky.bottomColor);
const fogColor = new THREE.Color(...planetMood.sky.fogColor);
const sunColor = new THREE.Color(...planetMood.sky.sunColor);

// Atmosphere tint for re-entry overlay
let fc = planetMood.sky.fogColor;
let atmosTint = `rgba(${Math.round(fc[0]*255)},${Math.round(fc[1]*255)},${Math.round(fc[2]*255)},`;

console.log(`[TGO] Planet mood: ${planetMood.bandLabel} (${planetMood.moodName}) ` +
    `@ ${planetFreq.frequency.toFixed(2)}Hz (${planetNote.display}) ` +
    `| Schumann distance: ${planetFreq.schumannDistance.toFixed(2)}Hz` +
    (planetMood.isSchumannResonant ? ' ★ RESONANT' : ''));

// Fog density driven by planet mood (Delta = thick fog, Alpha = clear, Gamma = toxic haze)
let moodFogDensity = planetMood.atmosphere.fogDensity;
scene.fog = new THREE.FogExp2(fogColor, moodFogDensity);

// NMS-style gradient sky dome — colors from harmonic resonance system
const skyDome = new SkyDome({
    topColor: skyTopColor,
    midColor: skyBottomColor,
    bottomColor: fogColor,
    fogColor: fogColor,
    sunDirection: new THREE.Vector3(0.5, 0.3, 0.4).normalize(),
    sunColor: sunColor,
});
skyDome.addToScene(scene); // Also sets scene.background = null

// ============================================================
// LIGHTING
// ============================================================
console.log('[TGO] Init: Sky dome ready, creating lights...');
setLoading(20, 'Igniting local star...');

// Main sun — directional with shadow casting
const sunLight = new THREE.DirectionalLight(sunColor, 2.8);
sunLight.position.set(100, 80, 60);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 0.5;
sunLight.shadow.camera.far = 300;
sunLight.shadow.camera.left = -80;
sunLight.shadow.camera.right = 80;
sunLight.shadow.camera.top = 80;
sunLight.shadow.camera.bottom = -80;
sunLight.shadow.bias = -0.0005;
sunLight.shadow.normalBias = 0.02;
scene.add(sunLight);
scene.add(sunLight.target);

// Ambient light intensity from mood (Delta worlds are dimmer, Beta worlds brighter)
const ambientLight = new THREE.AmbientLight(skyBottomColor, planetMood.atmosphere.ambientLight);
scene.add(ambientLight);

// Hemisphere light — sky color from above, warm earth tone from below
// This makes shadows take on the sky tint (blue shadows on blue worlds, etc.)
const hemiLight = new THREE.HemisphereLight(skyTopColor, 0x443322, 0.8);
scene.add(hemiLight);

// Fill light — warm bounce from below, prevents pitch-black undersides
const fillLight = new THREE.DirectionalLight(0xffaa66, 0.35);
fillLight.position.set(-30, -20, 20);
scene.add(fillLight);

// Rim light — subtle backlight that separates objects from background
const rimLight = new THREE.DirectionalLight(skyTopColor, 0.25);
rimLight.position.set(-50, 40, -80);
scene.add(rimLight);

// ============================================================
// CAMERA
// ============================================================
const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
// Start high up for descent
camera.position.set(0, 200, 0);
camera.lookAt(0, 0, 0);

// Camera MUST be added to scene for camera.add() children (FPS view model) to render
scene.add(camera);

// First-person view model (arm + multi-tool, visible on surface)
const fpsViewModel = new FPSViewModel(camera);

// Day/Night cycle — rotates sun, transitions sky colors, adjusts lighting
const dayNightCycle = new DayNightCycle({ startTime: 0.35, cycleDuration: 480 });
dayNightCycle.setPlanetMood(planetMood);

// Survival stats — health, stamina, hazard protection
const survivalStats = new SurvivalStats();
survivalStats.setPlanetHazard(planetMood.band);
survivalStats.onRespawn = () => {
    // Respawn at ship position
    if (shipModel && shipModel.group.visible) {
        const sp = shipModel.group.position;
        const groundH = terrainManager.getHeightAt(sp.x, sp.z) || 0;
        walker.enable(new THREE.Vector3(sp.x + 3, groundH + 1.7, sp.z + 3));
    }
};

// Finalize post-processing pipeline (needs camera + scene)
composer.addPass(new RenderPass(scene, camera));

// SSAO — NMS-style GTAO-like occlusion: wider kernel, more samples for terrain depth
const ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
ssaoPass.kernelRadius = 16;       // Wider radius — catches larger terrain features like NMS GTAO
ssaoPass.minDistance = 0.0005;    // Tighter min — catches small crevices
ssaoPass.maxDistance = 0.12;      // Balanced max — avoids halos on distant terrain
ssaoPass.output = SSAOPass.OUTPUT.Default;
composer.addPass(ssaoPass);

// Ray-marched atmosphere — volumetric scattering, aerial perspective, god rays
let atmospherePass = null;
try {
    atmospherePass = new RayMarchedAtmospherePass(camera, {
        skyColor: skyTopColor,
        fogColor: fogColor,
        sunColor: sunColor,
        sunDirection: new THREE.Vector3(0.5, 0.3, 0.4).normalize(),
        fogDensity: moodFogDensity,
        scatterStrength: planetMood.atmosphere.bloomStrength > 0.4 ? 1.2 : 0.8,
        godRayStrength: 0.25,
        aerialPerspective: 0.8,
        heightFalloff: 0.08,
    });
    composer.addPass(atmospherePass);
} catch (e) {
    console.warn('[TGO] Ray-marched atmosphere disabled:', e.message);
}

// Bloom — strength driven by planet mood (dreamlike Delta = more bloom, calm Alpha = less)
const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    planetMood.atmosphere.bloomStrength,  // mood-driven bloom
    0.85,   // radius (wide soft glow — slightly larger for cinematic feel)
    0.75    // threshold (slightly lower — catches more highlights for atmosphere)
);
composer.addPass(bloomPass);

// Color grading — the "painted sci-fi" look
const colorGradePass = new ShaderPass(colorGradeShader);
composer.addPass(colorGradePass);

// Film grain — 70s sci-fi texture, stronger in dark areas
composer.addPass(filmGrainPass);

// Output pass (applies tone mapping to final output)
composer.addPass(new OutputPass());

// ============================================================
// TERRAIN
// ============================================================
console.log('[TGO] Init: Post-processing pipeline ready, generating terrain...');
setLoading(30, `Generating terrain (Rule ${planetRule})...`);

let terrainManager = new TerrainManager(scene, {
    rule: planetRule,
    seed: planetSeed,
    moistureRule: (planetRule + 73) & 0xFF,
});
// Uses TERRAIN_CONFIG defaults (heightScale: 15, waterLevel: 0, etc.)

// NMS-style instanced grass — populates terrain near the camera
let grassSystem = new GrassSystem(scene, {
    baseColor: new THREE.Color(0x1a5e12), // Dark grass base (fake AO)
    tipColor: new THREE.Color(0x7ec850),  // Bright grass tips (sunlit)
    fogColor: fogColor,
    fogDensity: moodFogDensity,
});

// Scattered rocks — shapes derived from CA rule (supershape rocks)
let rockScatter = new RockScatter(scene, {
    planetRule: planetRule,
    rockSeed: hashSeed(planetSeed, 'rock'),
    rockColor: new THREE.Color(0x8a7d6b), // Fallback color
    fogColor: fogColor,
});

// Alien flora — supershape geometries driven by the planet's CA rule
// Wind strength from mood (Delta = still, Gamma = strong winds)
let alienFlora = new AlienFloraSystem(scene, {
    planetRule: planetRule,
    floraSeed: hashSeed(planetSeed, 'flora'),
    fogColor: fogColor,
    fogDensity: moodFogDensity,
    windStrength: planetMood.atmosphere.windStrength,
});

// Water plane — animated wave shader, follows camera
const sunDir = new THREE.Vector3(0.5, 0.3, 0.4).normalize();
terrainManager.createWater(fogColor, sunDir);

// Atmospheric dust/pollen particles — count + speed from planet mood
let atmosphericParticles = new AtmosphericParticles(scene, {
    color: new THREE.Color(0xddcc99),  // Warm dust motes
    fogColor: fogColor,
    fogDensity: moodFogDensity,
    count: planetMood.atmosphere.particleCount,
});

// Ground fill plane — prevents seeing sky color below terrain edges
// A huge flat plane at y=-1 colored to blend with distant terrain/fog
const groundFillGeo = new THREE.PlaneGeometry(10000, 10000);
groundFillGeo.rotateX(-Math.PI / 2);
const groundFillMat = new THREE.MeshBasicMaterial({ color: fogColor });
const groundFill = new THREE.Mesh(groundFillGeo, groundFillMat);
groundFill.position.y = -1;
scene.add(groundFill);

// ============================================================
// WALKING CONTROLLER
// ============================================================
const walker = new WalkingController(camera, canvas, (x, z) => {
    return terrainManager.getHeightAt(x, z);
});

// ============================================================
// TABLET UI
// ============================================================
const tablet = new TabletUI({
    onKeySubmit: (key) => {
        tablet.addDiscovery('Key of Insight accepted. The Architect awakens...', 'encounter');
        console.log('[TGO] Gemini API key provided (placeholder for API integration)');
    },
    planetData: {
        name: planetName,
        rule: planetRule,
        ruleClass: classification.class,
        ruleLabel: classification.label,
    },
});
tablet.setPlanetData({
    name: planetName,
    rule: planetRule,
    ruleClass: classification.class,
    ruleLabel: classification.label,
    archetype: classification.label,
    atmosphere: planetMood.moodName.charAt(0).toUpperCase() + planetMood.moodName.slice(1),
    hazard: planetMood.band === 'gamma' ? 'Extreme' : planetMood.band === 'beta' ? 'Moderate' : 'Low',
    frequency: `${planetFreq.frequency.toFixed(2)}Hz`,
    musicalNote: planetNote.display,
    brainwaveBand: planetMood.bandLabel,
    mood: planetMood.moodName,
    schumannResonant: planetMood.isSchumannResonant,
});

// ============================================================
// INVENTORY & MINING SYSTEMS
// ============================================================
const inventory = new InventoryManager();
const miningHUD = new MiningHUD();

// Mining system — Molecular Deconstructor
const miningSystem = new MiningSystem(scene, camera, {
    planetRule: planetRule,
    planetSeed: planetSeed,
    planetFrequency: planetFreq.frequency,
    inventory: inventory,
    onResourceCollected: (elementId, quantity, bonus) => {
        const el = ELEMENTS[elementId];
        if (el) {
            miningHUD.showPickup(el.symbol, quantity, el.color, bonus);
            tablet.addDiscovery(`Mined ${quantity} ${el.name} (${el.symbol})${bonus ? ' — ' + bonus : ''}`);
        }
    },
});

// Link inventory to tablet
tablet.setInventory(inventory);

// Performance manager — adaptive quality that looks good on ALL devices
const perfManager = new PerformanceManager(renderer);

// Wire perf manager to post-processing passes (so tier changes actually take effect)
perfManager.applyToComposer(composer, ssaoPass, bloomPass, filmGrainPass, colorGradePass);

// Set bloom base strength from planet mood (dreamy Delta = more bloom, etc.)
perfManager.setBloomBaseStrength(planetMood.atmosphere.bloomStrength);

// When quality tier changes, propagate to mining system
perfManager.onQualityChanged((tierName, settings) => {
    miningSystem.setQuality({
        quality: tierName,
        miningParticleCount: settings.miningParticleCount,
        miningBeamParticles: true,     // Keep beam particles at all tiers
        miningCrystalTrail: tierName !== 'POTATO',
    });
});

// ============================================================
// NPC MANAGER — The Mysterious Being
// ============================================================
let npcManager = new NPCManager(scene, {
    seed: planetSeed,
    rule: planetRule,
}, (x, z) => terrainManager.getHeightAt(x, z));

// ============================================================
// CREATURE SYSTEM — Procedural alien life forms
// ============================================================
let creatureSystem = null;
console.log('[TGO] Init: Creating creature system...');
try {
    creatureSystem = new CreatureSystem(scene, {
        planetRule: planetRule,
        planetSeed: planetSeed,
        getHeightAt: (x, z) => terrainManager.getHeightAt(x, z),
        getBiomeAt: (x, z) => terrainManager.getBiomeAt ? terrainManager.getBiomeAt(x, z) : 5,
        moodBand: planetMood.band,
        onCreatureAttack: (damage, creatureName) => {
            survivalStats.takeDamage(damage, 'creature');
            audioManager.playSFX('mining_stop'); // hit sound
        },
    });
} catch (e) {
    console.warn('[TGO] Creature system disabled:', e.message);
}

// ============================================================
// SHIP + FLIGHT SYSTEMS
// ============================================================

// Ship model — "Voidmoth" Mk-I starter ship
const shipModel = new ShipModel({
    hullColor: new THREE.Color(0x5a6577),
    accentColor: new THREE.Color(0xb83232),
    engineColor: new THREE.Color(0x33ddff),
});
shipModel.setLandingGear(true);
shipModel.addToScene(scene);

// Ship position — placed 15m away from landing spot
const shipSpawnOffset = new THREE.Vector3(15, 0, 10);
let shipGrounded = false; // Will be set in onLanded()

// Flight controller
const flightController = new FlightController(
    camera, canvas, shipModel,
    (x, z) => terrainManager.getHeightAt(x, z)
);

// Weapon system
const weaponSystem = new WeaponSystem(scene, shipModel);
weaponSystem.setGetHeightAt((x, z) => terrainManager.getHeightAt(x, z));
// weaponSystem.onFire → audioManager.playSFX (wired below)

// Scanner system
const scannerSystem = new ScannerSystem(scene, {
    name: planetName,
    rule: planetRule,
    ruleClass: classification.class,
    ruleLabel: classification.label,
    frequency: `${planetFreq.frequency.toFixed(2)}Hz`,
    musicalNote: planetNote.display,
    brainwaveBand: planetMood.bandLabel,
    mood: planetMood.moodName,
    atmosphere: planetMood.moodName.charAt(0).toUpperCase() + planetMood.moodName.slice(1),
    hazard: planetMood.band === 'gamma' ? 'Extreme' : planetMood.band === 'beta' ? 'Moderate' : 'Low',
    schumannResonant: planetMood.isSchumannResonant,
});

// scannerSystem.onScan → audioManager.playSFX (wired below)

// Hyperspace system
const hyperspaceSystem = new HyperspaceSystem(scene, camera);

// Ship HUD
const shipHUD = new ShipHUD();

// ============================================================
// AUDIO — Procedural Pioneer-style sound (Web Audio API)
// ============================================================
const audioManager = new AudioManager();
audioManager.setPlanet(planetFreq.frequency, planetFreq.band, planetMood.moodName);

// Init audio on first user gesture (browser requires user interaction)
const _initAudioOnGesture = () => {
    audioManager.init();
    audioManager.setPlanet(planetFreq.frequency, planetFreq.band, planetMood.moodName);
    audioManager.setPhase(currentPhase);
    audioManager.playSFX('reentry'); // Descent begins
    document.removeEventListener('click', _initAudioOnGesture);
    document.removeEventListener('keydown', _initAudioOnGesture);
};
document.addEventListener('click', _initAudioOnGesture);
document.addEventListener('keydown', _initAudioOnGesture);

// Wire audio callbacks to weapon + scanner systems
weaponSystem.onFire = () => audioManager.playSFX('weapon_fire');
scannerSystem.onScan = () => audioManager.playSFX('scan_ping');

// M key — toggle mute
document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyM' && !e.ctrlKey && !e.altKey) {
        const muted = audioManager.toggleMute();
        console.log(`[TGO Audio] ${muted ? 'MUTED' : 'UNMUTED'}`);
    }
});

// ============================================================
// GALAXY NAVIGATION — GalaxyMap + SystemView
// ============================================================

// Player's galactic position (which star system they're in)
let currentSystemX = initialSystemX;
let currentSystemY = initialSystemY;

// Galaxy Map — 2D star picker
const galaxyMap = new GalaxyMap({
    onSystemSelected: (systemEntry) => {
        // Player clicked a star on the galaxy map → open 3D system view
        galaxyMap.close();
        currentPhase = PHASE.SYSTEM_VIEW;
        systemView.open(systemEntry.system);
        audioManager.setPhase('system_view');
        audioManager.playSFX('ui_click');
    },
    onCancel: () => {
        // ESC pressed on galaxy map → return to flight
        returnToFlight();
        audioManager.playSFX('ui_close');
    },
});

// System View — 3D planet picker
const systemView = new SystemView({
    onPlanetSelected: (ghost, systemData) => {
        // Player clicked a landable planet → warp to it
        systemView.close();

        // Update galactic position
        currentSystemX = systemData.coordinates.x;
        currentSystemY = systemData.coordinates.y;
        galaxyMap.setPlayerPosition(currentSystemX, currentSystemY);

        // Audio: warp flash + planet transition
        audioManager.playSFX('warp_flash');

        // Warp to the selected planet
        transitionToPlanet(ghost.rule, ghost.seed);
    },
    onBack: () => {
        // Return to galaxy map from system view
        currentPhase = PHASE.GALAXY_MAP;
        galaxyMap.open(currentSystemX, currentSystemY);
        audioManager.setPhase('galaxy_map');
        audioManager.playSFX('ui_click');
    },
    onCancel: () => {
        // ESC pressed on system view → return to flight
        returnToFlight();
        audioManager.playSFX('ui_close');
    },
});

/**
 * Return to flight mode from galaxy/system view (ESC cancel).
 * Repositions the ship and re-enables flight systems.
 */
function returnToFlight() {
    currentPhase = PHASE.FLIGHT;

    // Re-enable flight systems at current ship position
    const shipPos = shipModel.group.position.clone();
    shipPos.y = Math.max(shipPos.y, 80); // Ensure above tallest terrain
    flightController.enable(shipPos);
    weaponSystem.enable();
    scannerSystem.enable();
    hyperspaceSystem.enable();
    shipHUD.show();

    document.getElementById('phaseName').textContent = 'FLIGHT MODE';
    document.getElementById('phaseInfo').textContent = `${planetName} · Ship Active`;

    // Audio: back to flight
    audioManager.setPhase('flight');

    console.log('[TGO] Returned to flight mode (navigation cancelled)');
}

// ============================================================
// SEAMLESS PLANET TRANSITION — no loading screen, no page reload
// ============================================================
// When the player jumps to a new planet via hyperspace, this function
// disposes the old world and recreates everything with new parameters.
// The flash overlay hides the transition; descent animation plays on arrival.
//
// Flow: FLIGHT → charge → GALAXY_MAP → SYSTEM_VIEW → warp → DESCENT → SURFACE

// Hyperspace audio hooks
hyperspaceSystem.onChargeStart = () => audioManager.playSFX('hyperspace_charge_start');
hyperspaceSystem.onChargeCancel = () => audioManager.playSFX('hyperspace_charge_cancel');

hyperspaceSystem.onJump = () => {
    // Hyperspace charged → open galaxy map for destination selection
    currentPhase = PHASE.GALAXY_MAP;

    // Disable flight systems while in map
    flightController.disable();
    weaponSystem.disable();
    scannerSystem.disable();
    hyperspaceSystem.disable();
    shipHUD.hide();

    hyperspaceSystem.resetJumpState();
    galaxyMap.open(currentSystemX, currentSystemY);

    // Audio: switch to terminal/map ambience
    audioManager.playSFX('hyperspace_jump');
    audioManager.setPhase('galaxy_map');
    audioManager.playSFX('ui_open');
};

function transitionToPlanet(newRule, newSeed) {
    // ---- Flash overlay for warp effect ----
    hyperspaceSystem.flashOverlay.style.opacity = '1';

    // ---- Phase lock: prevent game loop from updating stale systems ----
    currentPhase = PHASE.DESCENT;

    // ---- Disable all active systems ----
    walker.disable();
    miningSystem.disable();
    fpsViewModel.hide();
    survivalStats.hide();
    flightController.disable();
    weaponSystem.disable();
    scannerSystem.disable();
    hyperspaceSystem.disable();
    shipHUD.hide();
    document.getElementById('crosshair').classList.remove('visible');
    document.getElementById('controls-hint').classList.remove('visible');

    // ---- Dispose planet-specific systems (geometry, materials, meshes) ----
    terrainManager.dispose();
    grassSystem.dispose();
    rockScatter.dispose();
    alienFlora.dispose();
    atmosphericParticles.dispose();
    npcManager.dispose();
    if (creatureSystem) creatureSystem.dispose();

    // ---- Update planet identity ----
    planetRule = newRule;
    planetSeed = newSeed;
    planetName = generatePlanetName(hashSeed(planetSeed, 'planet', 0));

    // Update URL so refresh works (no page reload)
    history.replaceState(null, '', `landing.html?rule=${newRule}&seed=${newSeed}&sx=${currentSystemX}&sy=${currentSystemY}`);

    // ---- Recalculate planet characteristics from CA rule + seed ----
    classification = classifyRule(planetRule);
    planetMood = derivePlanetMood(planetRule, planetSeed);
    planetFreq = derivePlanetFrequency(planetRule, planetSeed);
    planetNote = frequencyToNote(planetFreq.frequency);

    // ---- Recalculate colors ----
    skyTopColor.set(...planetMood.sky.topColor);
    skyBottomColor.set(...planetMood.sky.bottomColor);
    fogColor.set(...planetMood.sky.fogColor);
    sunColor.set(...planetMood.sky.sunColor);
    fc = planetMood.sky.fogColor;
    atmosTint = `rgba(${Math.round(fc[0]*255)},${Math.round(fc[1]*255)},${Math.round(fc[2]*255)},`;
    moodFogDensity = planetMood.atmosphere.fogDensity;

    // ---- Update day/night cycle for new planet ----
    dayNightCycle.setPlanetMood(planetMood);
    dayNightCycle.timeOfDay = 0.35; // Fresh morning on new planet
    dayNightCycle.update(0); // Compute initial values

    // ---- Update survival stats for new planet hazard ----
    survivalStats.setPlanetHazard(planetMood.band);
    survivalStats.hazardProtection = survivalStats.maxHazardProtection;

    // ---- Update scene fog ----
    scene.fog.color.copy(fogColor);
    scene.fog.density = moodFogDensity;

    // ---- Update sky dome (day/night cycle will maintain these) ----
    skyDome.material.uniforms.uTopColor.value.copy(skyTopColor);
    skyDome.material.uniforms.uMidColor.value.copy(skyBottomColor);
    skyDome.material.uniforms.uBottomColor.value.copy(fogColor);
    skyDome.material.uniforms.uFogColor.value.copy(fogColor);
    skyDome.material.uniforms.uSunColor.value.copy(sunColor);

    // ---- Update lighting ----
    sunLight.color.copy(sunColor);
    ambientLight.color.copy(skyBottomColor);
    ambientLight.intensity = planetMood.atmosphere.ambientLight;
    hemiLight.color.copy(skyTopColor);
    groundFillMat.color.copy(fogColor);

    // ---- Update bloom strength for new planet mood ----
    perfManager.setBloomBaseStrength(planetMood.atmosphere.bloomStrength);

    // ---- Update ray-marched atmosphere for new planet ----
    if (atmospherePass) atmospherePass.setAtmosphere({
        skyColor: skyTopColor,
        fogColor: fogColor,
        sunColor: sunColor,
        fogDensity: moodFogDensity,
        scatterStrength: planetMood.atmosphere.bloomStrength > 0.4 ? 1.2 : 0.8,
    });

    // ---- Recreate terrain (new CA rule + seed = new world) ----
    terrainManager = new TerrainManager(scene, {
        rule: planetRule,
        seed: planetSeed,
        moistureRule: (planetRule + 73) & 0xFF,
    });
    const newSunDir = new THREE.Vector3(0.5, 0.3, 0.4).normalize();
    terrainManager.createWater(fogColor, newSunDir);

    // ---- Recreate vegetation + environment ----
    grassSystem = new GrassSystem(scene, {
        baseColor: new THREE.Color(0x1a5e12),
        tipColor: new THREE.Color(0x7ec850),
        fogColor: fogColor,
        fogDensity: moodFogDensity,
    });

    rockScatter = new RockScatter(scene, {
        planetRule: planetRule,
        rockSeed: hashSeed(planetSeed, 'rock'),
        rockColor: new THREE.Color(0x8a7d6b),
        fogColor: fogColor,
    });

    alienFlora = new AlienFloraSystem(scene, {
        planetRule: planetRule,
        floraSeed: hashSeed(planetSeed, 'flora'),
        fogColor: fogColor,
        fogDensity: moodFogDensity,
        windStrength: planetMood.atmosphere.windStrength,
    });

    // ---- Recreate atmospheric particles ----
    atmosphericParticles = new AtmosphericParticles(scene, {
        color: new THREE.Color(0xddcc99),
        fogColor: fogColor,
        fogDensity: moodFogDensity,
        count: planetMood.atmosphere.particleCount,
    });

    // ---- Recreate NPCs ----
    npcManager = new NPCManager(scene, {
        seed: planetSeed,
        rule: planetRule,
    }, (x, z) => terrainManager.getHeightAt(x, z));

    // ---- Recreate creature system ----
    try {
        creatureSystem = new CreatureSystem(scene, {
            planetRule: planetRule,
            planetSeed: planetSeed,
            getHeightAt: (x, z) => terrainManager.getHeightAt(x, z),
            getBiomeAt: (x, z) => terrainManager.getBiomeAt ? terrainManager.getBiomeAt(x, z) : 5,
            moodBand: planetMood.band,
            onCreatureAttack: (damage, creatureName) => {
                survivalStats.takeDamage(damage, 'creature');
                audioManager.playSFX('mining_stop');
            },
        });
    } catch (e) {
        console.warn('[TGO] Creature system recreation failed:', e.message);
        creatureSystem = null;
    }

    // ---- Reset encounter state ----
    encounterState = 'waiting';
    beingDialogueIndex = 0;

    // ---- Update tablet with new planet data ----
    tablet.setPlanetData({
        name: planetName,
        rule: planetRule,
        ruleClass: classification.class,
        ruleLabel: classification.label,
        archetype: classification.label,
        atmosphere: planetMood.moodName.charAt(0).toUpperCase() + planetMood.moodName.slice(1),
        hazard: planetMood.band === 'gamma' ? 'Extreme' : planetMood.band === 'beta' ? 'Moderate' : 'Low',
        frequency: `${planetFreq.frequency.toFixed(2)}Hz`,
        musicalNote: planetNote.display,
        brainwaveBand: planetMood.bandLabel,
        mood: planetMood.moodName,
        schumannResonant: planetMood.isSchumannResonant,
    });
    tablet.addDiscovery(`Warped to ${planetName} (Rule ${planetRule}).`, 'discovery');

    // ---- Reset descent state machine ----
    descentProgress = 0;
    descentLanded = false;
    shipGrounded = false;

    // ---- Hide ship during descent (repositioned on landing) ----
    shipModel.group.visible = false;
    shipModel.setLandingGear(true);

    // ---- Camera to descent start position (above terrain peaks) ----
    camera.position.set(0, descentStartHeight, 0);
    camera.lookAt(0, 0, 0);

    // ---- Update audio for new planet ----
    audioManager.setPlanet(planetFreq.frequency, planetFreq.band, planetMood.moodName);
    audioManager.setPhase('descent');
    audioManager.playSFX('reentry');

    // ---- Fade out flash → descent begins on next frame ----
    setTimeout(() => {
        hyperspaceSystem.flashOverlay.style.opacity = '0';
        hyperspaceSystem.resetJumpState();
    }, 300);

    // ---- Auto-save galactic position ----
    saveGame();

    console.log(
        `[TGO] ★ Warped to ${planetName} ` +
        `(Rule ${planetRule}, Seed ${planetSeed}, ${planetMood.bandLabel} ${planetMood.moodName}) ` +
        `@ System [${currentSystemX}, ${currentSystemY}]`
    );
}

// World position helper (for when camera is child of ship)
const _shipWorldPos = new THREE.Vector3();

// E key — enter/exit ship
function handleShipToggle() {
    if (currentPhase === PHASE.SURFACE) {
        // Check if near ship
        const playerPos = camera.position;
        const shipPos = shipModel.group.position;
        const dist = playerPos.distanceTo(shipPos);

        if (dist < 8) {
            // Enter ship!
            enterShip();
        }
    } else if (currentPhase === PHASE.FLIGHT) {
        // Exit ship — start landing
        exitShip();
    }
}

function enterShip() {
    currentPhase = PHASE.FLIGHT;

    // Disable walking
    walker.disable();

    miningSystem.disable();

    // Hide walking HUD elements
    document.getElementById('crosshair').classList.remove('visible');
    document.getElementById('controls-hint').classList.remove('visible');
    shipHUD.hideEnterPrompt();

    // Enable flight systems
    const shipPos = shipModel.group.position.clone();
    shipPos.y += 5; // Lift off slightly
    flightController.enable(shipPos);
    weaponSystem.enable();
    scannerSystem.enable();
    hyperspaceSystem.enable();
    shipHUD.show();

    // Update phase HUD
    document.getElementById('phaseName').textContent = 'FLIGHT MODE';
    document.getElementById('phaseInfo').textContent = `${planetName} · System [${currentSystemX}, ${currentSystemY}]`;

    // Hide first-person view model in ship
    fpsViewModel.hide();

    // Hide survival HUD in ship
    survivalStats.hide();

    // Audio: switch to flight (engine + space ambience)
    audioManager.setPhase('flight');
    audioManager.playSFX('ui_open');

    console.log('[TGO] Entered ship — flight mode active');
}

function exitShip() {
    // Start auto-landing sequence
    flightController.startLanding(() => {
        // Landing complete — switch to walking
        currentPhase = PHASE.SURFACE;

        // Disable flight systems
        const landPos = flightController.disable();
        weaponSystem.disable();
        scannerSystem.disable();
        hyperspaceSystem.disable();
        shipHUD.hide();

        // Enable walking at ship position
        const groundH = terrainManager.getHeightAt(landPos.x, landPos.z) || 0;
        const walkStart = new THREE.Vector3(landPos.x + 3, groundH + 1.7, landPos.z + 3);
        walker.enable(walkStart);

        miningSystem.enable();

        // Show walking HUD
        document.getElementById('crosshair').classList.add('visible');

        // Update phase HUD
        document.getElementById('phaseName').textContent = 'SURFACE EXPLORATION';
        document.getElementById('phaseInfo').textContent = `${planetName} · Rule ${planetRule}`;

        // Show first-person view model
        fpsViewModel.show();

        // Show survival HUD
        survivalStats.show();

        // Audio: switch to surface ambience
        audioManager.setPhase('surface');
        audioManager.playSFX('landing');

        console.log('[TGO] Exited ship — surface exploration');
    });
}

// Global E key listener (always active after landing)
document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyE' && (currentPhase === PHASE.SURFACE || currentPhase === PHASE.FLIGHT)) {
        // Don't toggle during dialogue or tablet
        if (dialogue && dialogue.isDialogueActive()) return;
        if (tablet && tablet.isOpen) return;
        handleShipToggle();
    }
});

// ============================================================
// SHIP SUMMON MENU (X KEY)
// ============================================================
let shipMenuOpen = false;

function toggleShipMenu() {
    const menu = document.getElementById('ship-menu');
    shipMenuOpen = !shipMenuOpen;
    if (shipMenuOpen) {
        menu.classList.add('visible');
        // Release pointer lock so mouse can click menu items
        if (document.pointerLockElement) document.exitPointerLock();
    } else {
        menu.classList.remove('visible');
    }
}

function closeShipMenu() {
    const menu = document.getElementById('ship-menu');
    shipMenuOpen = false;
    menu.classList.remove('visible');
}

function summonShipToPlayer() {
    const playerPos = camera.position;
    // Place ship 8m in front of where the player is looking
    const lookDir = walker.getLookDirection();
    const shipX = playerPos.x + lookDir.x * 12;
    const shipZ = playerPos.z + lookDir.z * 12;
    const shipGroundH = terrainManager.getHeightAt(shipX, shipZ) || 0;

    shipModel.group.position.set(shipX, shipGroundH + 3.5, shipZ);
    shipModel.group.visible = true;
    shipModel.setLandingGear(true);
    shipGrounded = true;

    tablet.addDiscovery('Ship summoned to your location. Press E to board.');
    audioManager.playSFX('landing');
    closeShipMenu();
    console.log('[TGO] Ship summoned to player position');
}

function teleportToShip() {
    if (!shipModel.group.visible) {
        // Ship not on planet, summon it first
        summonShipToPlayer();
        return;
    }

    const shipPos = shipModel.group.position;
    const groundH = terrainManager.getHeightAt(shipPos.x + 3, shipPos.z + 3) || 0;
    walker.enable(new THREE.Vector3(shipPos.x + 3, groundH + 1.7, shipPos.z + 3));
    closeShipMenu();
    console.log('[TGO] Teleported to ship');
}

// Ship menu button handlers
document.getElementById('menu-summon-ship').addEventListener('click', () => {
    summonShipToPlayer();
});
document.getElementById('menu-board-ship').addEventListener('click', () => {
    teleportToShip();
    // Slight delay then enter ship
    setTimeout(() => {
        if (currentPhase === PHASE.SURFACE) {
            enterShip();
        }
    }, 100);
});
document.getElementById('menu-ship-status').addEventListener('click', () => {
    // Just close the menu and show status in tablet
    closeShipMenu();
    tablet.addDiscovery('Voidmoth Mk-I Status: All systems nominal. Hull: 100%. Fuel: 87%.');
});

// X key handler
document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyX' && currentPhase === PHASE.SURFACE) {
        if (dialogue && dialogue.isDialogueActive()) return;
        if (tablet && tablet.isOpen) return;
        toggleShipMenu();
    }
    // Also close menu on Escape
    if (e.code === 'Escape' && shipMenuOpen) {
        closeShipMenu();
    }
});

// ============================================================
// DIALOGUE SYSTEM
// ============================================================
let encounterState = 'waiting'; // waiting | approaching | talking | complete
let beingDialogueIndex = 0;

const dialogue = new DialogueSystem({
    onDialogueComplete: () => {
        if (encounterState === 'talking') {
            beingDialogueIndex++;
            if (beingDialogueIndex >= BEING_DIALOGUES.length) {
                encounterState = 'complete';
                // Unlock the key input on the tablet
                tablet.unlockKeyInput();
                tablet.addDiscovery(
                    'The Mysterious Being revealed the truth: this universe runs on Cellular Automata. ' +
                    'It asks for the "Key of Insight" to awaken the Architect.',
                    'encounter'
                );
            } else {
                encounterState = 'approaching';
            }
        }
        // Re-enable walking
        walker.enable();
    },
    onChoice: (choiceId) => {
        if (choiceId === 'ask_key') {
            // Show final dialogue about the key
            dialogue.startDialogue('THE BEING', [
                'The Key of Insight… it is not a word or a cipher.',
                'It is a bridge between your consciousness and the Architect who shaped this cosmos.',
                'Open your Tablet. You will find a place to enter it.',
                'When the Key is given, the Architect will speak… and your understanding of this universe will change forever.',
            ], { speakerColor: '#88ffcc' });
        } else if (choiceId === 'ask_rules') {
            dialogue.startDialogue('THE BEING', [
                'Each world is born from a Rule — a number between 0 and 255.',
                `This world… it was born from Rule ${planetRule}. A Class ${classification.class} pattern.`,
                classification.class === 3
                    ? 'Class 3 — Chaotic. The most beautiful patterns emerge from chaos. Like life itself.'
                    : classification.class === 4
                    ? 'Class 4 — Complex. The edge of chaos. These patterns can compute, can think, can dream.'
                    : classification.class === 2
                    ? 'Class 2 — Periodic. Orderly. Predictable. Like a heartbeat that never falters.'
                    : 'Class 1 — Uniform. Silent. Still. The void between thoughts.',
                'Every mountain you see, every valley you walk through — all computed from that single number.',
            ], { speakerColor: '#88ffcc' });
        } else if (choiceId === 'leave') {
            encounterState = 'complete';
        }
    },
});

// The Being's dialogue tree
const BEING_DIALOGUES = [
    // First encounter
    {
        lines: [
            'You have arrived.',
            'I have watched the patterns form beneath my gaze for aeons…',
            'The stone beneath your feet. The sky above. The mountains on the horizon.',
            'They are not random.',
            'They are computed.',
        ],
        speakerColor: '#88ffcc',
    },
    // Second conversation (when approached again)
    {
        lines: [
            'The patterns in the stone… they are not random. To see the truth, you must provide the Key of Insight.',
            'I am what remains of the first consciousness to understand this universe\'s source code.',
            'These worlds — all of them — grow from simple rules. Cellular Automata.',
            'Two hundred and fifty-six possible rules. Each one a different universe.',
        ],
        speakerColor: '#88ffcc',
        choices: [
            { text: 'What are these "rules"?', id: 'ask_rules' },
            { text: 'Tell me about the Key of Insight.', id: 'ask_key' },
            { text: 'I need to explore more first.', id: 'leave' },
        ],
    },
];

function triggerBeingDialogue() {
    if (beingDialogueIndex >= BEING_DIALOGUES.length) return;

    encounterState = 'talking';
    const d = BEING_DIALOGUES[beingDialogueIndex];

    // Disable walking during dialogue
    walker.disable();

    // Log the discovery
    if (beingDialogueIndex === 0) {
        tablet.addDiscovery(`Encountered the Mysterious Being on ${planetName}.`, 'encounter');
    }

    dialogue.startDialogue('THE BEING', d.lines, {
        speakerColor: d.speakerColor || '#88ffcc',
        choices: d.choices || null,
    });

    // Mark as approached
    if (npcManager.mysteriousBeing) {
        npcManager.mysteriousBeing.hasBeenApproached = true;
    }
}

// ============================================================
// DESCENT ANIMATION
// ============================================================
let descentProgress = 0;
const descentDuration = 6.0; // seconds
const descentStartHeight = 400;
const descentEndHeight = 55; // safely above tallest terrain peaks
let descentLanded = false;

function updateDescent(dt) {
    descentProgress += dt / descentDuration;

    if (descentProgress >= 1.0) {
        descentProgress = 1.0;
        if (!descentLanded) {
            descentLanded = true;
            onLanded();
        }
        return;
    }

    // Smooth descent curve (fast at start, slow at end)
    const t = 1.0 - Math.pow(1.0 - descentProgress, 3);
    const height = descentStartHeight * (1 - t) + descentEndHeight * t;

    // Slight forward drift
    const forwardDrift = t * 20;

    // Camera shake during re-entry (strongest at start, fades as we slow down)
    let shakeX = 0, shakeY = 0;
    if (descentProgress < 0.6) {
        const shakeIntensity = (1.0 - descentProgress / 0.6) * 1.5;
        const shakeFreq = 15 + descentProgress * 20; // Gets faster, then calms
        shakeX = Math.sin(descentProgress * shakeFreq * 6.28) * shakeIntensity *
                 (0.5 + Math.sin(descentProgress * 47) * 0.5);
        shakeY = Math.cos(descentProgress * shakeFreq * 5.13) * shakeIntensity * 0.6;
    }

    camera.position.set(
        Math.sin(descentProgress * 0.5) * 5 + shakeX,
        height + shakeY,
        forwardDrift
    );

    // Look slightly ahead and down
    const lookY = height * 0.3;
    camera.lookAt(0, lookY, forwardDrift + 20);

    // Atmosphere overlay intensity
    const atmosOverlay = document.getElementById('atmos-overlay');
    if (descentProgress < 0.3) {
        // Re-entry glow (orange) — intense plasma heating effect
        const baseIntensity = Math.sin(descentProgress / 0.3 * Math.PI) * 0.4;
        // Flickering fire effect during re-entry
        const flicker = 0.05 * Math.sin(descentProgress * 80) + 0.03 * Math.sin(descentProgress * 130);
        const intensity = baseIntensity + flicker;
        // Edge glow: orange center → red edges for realistic re-entry
        atmosOverlay.style.background =
            `radial-gradient(ellipse at center, ` +
            `rgba(255,180,80,${intensity * 0.3}), ` +
            `rgba(255,120,30,${intensity * 0.7}), ` +
            `rgba(200,50,10,${intensity * 0.4}) 70%, ` +
            `transparent)`;
        atmosOverlay.style.opacity = 1;
    } else if (descentProgress < 0.7) {
        // Atmosphere haze (planet tint fading in)
        const hazeIntensity = (descentProgress - 0.3) / 0.4 * 0.15;
        atmosOverlay.style.background = atmosTint + hazeIntensity + ')';
        atmosOverlay.style.opacity = 1;
    } else {
        atmosOverlay.style.opacity = 0;
    }

    // Altitude display
    document.getElementById('altitudeValue').textContent =
        `${Math.round(height)}m`;

    // Update terrain around descent path
    terrainManager.update(camera.position, camera, dt);
    // Sky dome follows camera during descent too
    skyDome.update(camera.position, descentProgress * descentDuration);
    // Day/night cycle during descent
    dayNightCycle.update(dt);
    dayNightCycle.applyToScene({
        skyDome, sunLight, ambientLight, hemiLight,
        fillLight, rimLight, fog: scene.fog,
        atmospherePass, groundFillMat,
    });
    dayNightCycle.updateSunPosition(sunLight, camera.position);
    // Water waves animate during descent
    terrainManager.updateWater(descentProgress * descentDuration, camera.position);
    // Particles visible during descent
    atmosphericParticles.update(camera.position, descentProgress * descentDuration);
}

// ============================================================
// LANDING — transition to walking
// ============================================================
function onLanded() {
    currentPhase = PHASE.SURFACE;

    // Show planet name banner
    const banner = document.getElementById('planet-banner');
    document.getElementById('bannerName').textContent = planetName.toUpperCase();
    document.getElementById('bannerSubtitle').textContent =
        `Rule ${planetRule} · ${planetMood.bandLabel} ${planetMood.moodName} · ${planetFreq.frequency.toFixed(1)}Hz (${planetNote.display})` +
        (planetMood.isSchumannResonant ? ' · ★ RESONANT' : '');
    banner.classList.add('visible');

    // Fade out banner after 3 seconds
    setTimeout(() => {
        banner.classList.remove('visible');
    }, 4000);

    // Show controls hint
    setTimeout(() => {
        document.getElementById('controls-hint').classList.add('visible');
        document.getElementById('crosshair').classList.add('visible');
    }, 1500);

    // Hide controls hint after 8 seconds
    setTimeout(() => {
        document.getElementById('controls-hint').classList.remove('visible');
    }, 9000);

    // Find a good landing spot (get ground height at current position)
    const groundH = terrainManager.getHeightAt(camera.position.x, camera.position.z) || 5;
    const startPos = new THREE.Vector3(
        camera.position.x,
        groundH + 1.7,
        camera.position.z
    );

    // Enable walking
    walker.enable(startPos);

    // Enable mining tool
    miningSystem.enable();

    // Update phase HUD
    document.getElementById('phaseName').textContent = 'SURFACE EXPLORATION';
    document.getElementById('phaseInfo').textContent =
        `${planetName} · Rule ${planetRule}`;

    // Position the ship on the ground near the player
    const shipX = camera.position.x + shipSpawnOffset.x;
    const shipZ = camera.position.z + shipSpawnOffset.z;
    const shipGroundH = terrainManager.getHeightAt(shipX, shipZ) || groundH;
    shipModel.group.position.set(shipX, shipGroundH + 3.5, shipZ);
    shipModel.group.visible = true; // Ensure visible after hyperspace warp
    shipGrounded = true;

    // Audio: switch to surface ambience
    audioManager.setPhase('surface');
    audioManager.playSFX('landing');

    // Show first-person view model (arm + multi-tool)
    fpsViewModel.show();

    // Show survival HUD
    survivalStats.show();

    // Spawn the Mysterious Being
    setTimeout(() => {
        npcManager.spawnMysteriousBeing();
        tablet.addDiscovery(`Landed on ${planetName}. Surface exploration initiated.`);
        tablet.addDiscovery(`Anomalous energy signature detected nearby...`);
        tablet.addDiscovery(`Your ship — Voidmoth Mk-I — is parked nearby. Press E to board.`);
    }, 2000);
}

// ============================================================
// RESIZE
// ============================================================
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    if (atmospherePass) atmospherePass.setSize(window.innerWidth, window.innerHeight);
});

// ============================================================
// GAME LOOP
// ============================================================
const clock = new THREE.Clock();
let frameCount = 0, lastFpsTime = 0;
let _wasMining = false;

console.log('[TGO] Init: All systems ready, starting game loop...');
setLoading(100, 'Entering atmosphere...');

// Quick fade — the descent animation IS the loading experience
setTimeout(() => {
    loadingEl.classList.add('fade');
    setTimeout(() => { loadingEl.style.display = 'none'; }, 1200);
}, 300);

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const t = clock.getElapsedTime();

    // Phase-specific update
    if (currentPhase === PHASE.DESCENT) {
        updateDescent(dt);
    } else if (currentPhase === PHASE.SURFACE) {
        // Don't update walking during dialogue or tablet
        if (!dialogue.isDialogueActive() && !tablet.isOpen) {
            walker.update(dt);
        }
        terrainManager.update(camera.position, camera, dt);

        // Sky dome follows camera
        skyDome.update(camera.position, t);

        // Grass — populate terrain chunks near camera with instanced blades
        grassSystem.update(terrainManager.chunks, camera.position, t);

        // Rocks — scattered boulders for surface detail
        rockScatter.update(terrainManager.chunks, camera.position);

        // Alien flora — crystal spires, mushroom trees, glowing stalks
        alienFlora.update(terrainManager.chunks, camera.position, t);

        // Water — animated waves, specular highlights
        terrainManager.updateWater(t, camera.position);

        // Atmospheric particles — floating dust/pollen
        atmosphericParticles.update(camera.position, t);

        // Mining system — beam, particles, crystal pickups
        miningSystem.setMineableMeshes(
            Array.from(rockScatter.rockChunks.values()),
            Array.from(alienFlora.chunkMeshes.values()).flat()
        );
        miningSystem.update(dt);
        miningHUD.update(dt);

        // Update mining HUD + audio
        const miningInfo = miningSystem.getHUDInfo();
        miningHUD.updateHeat(miningInfo.heatPct, miningInfo.isOverheated);

        // Mining audio triggers
        if (miningInfo.isFiring && !_wasMining) {
            audioManager.playSFX('mining_start');
        } else if (!miningInfo.isFiring && _wasMining) {
            audioManager.playSFX('mining_stop');
        }
        _wasMining = miningInfo.isFiring;

        // Update first-person view model (arm + multi-tool sway/bob)
        fpsViewModel.setMining(miningInfo.isFiring);
        fpsViewModel.update(dt, {
            yaw: walker.rotation.yaw,
            pitch: walker.rotation.pitch,
            speed: Math.sqrt(walker.velocity.x ** 2 + walker.velocity.z ** 2),
            headBobOffset: walker.headBobOffset,
        });

        // Update inventory display in tablet if open
        if (tablet.isOpen) {
            tablet.updateInventory();
            tablet.updateRefinery();
        }

        // Update refinery process
        inventory.updateRefinery(dt);

        // Ground fill follows camera (prevents seeing sky below terrain edges)
        groundFill.position.x = camera.position.x;
        groundFill.position.z = camera.position.z;

        // Update NPCs
        npcManager.update(dt, camera.position);

        // Update alien creatures
        if (creatureSystem) creatureSystem.update(dt, camera.position);

        // Check Mysterious Being proximity
        if (npcManager.mysteriousBeing && encounterState !== 'talking') {
            const proximity = npcManager.checkMysteriousBeingProximity(camera.position);

            if (proximity.inRange && encounterState !== 'complete') {
                dialogue.hideProximityHint();
                if (encounterState !== 'talking') {
                    triggerBeingDialogue();
                }
            } else if (proximity.inGlowRange && encounterState === 'waiting') {
                dialogue.showProximityHint();
            } else {
                dialogue.hideProximityHint();
            }
        }

        // Update tablet coordinates
        if (tablet.isOpen) {
            tablet.setCoordinates(camera.position.x, camera.position.y, camera.position.z);
        }

        // Day/night cycle — rotates sun, transitions sky/lighting
        dayNightCycle.update(dt);
        dayNightCycle.applyToScene({
            skyDome, sunLight, ambientLight, hemiLight,
            fillLight, rimLight, fog: scene.fog,
            atmospherePass, groundFillMat,
        });
        dayNightCycle.updateSunPosition(sunLight, camera.position);

        // Survival stats — health, stamina, hazard protection
        survivalStats.update(dt, {
            isSprinting: walker.isSprinting && survivalStats.canSprint(),
            isGrounded: walker.isGrounded,
            fallVelocity: walker.velocity.y,
            isInShip: false,
        });

        // Prevent sprinting when stamina is empty
        if (!survivalStats.canSprint()) {
            walker.keys['ShiftLeft'] = false;
            walker.keys['ShiftRight'] = false;
        }

        // Check ship proximity (show "Press E" prompt)
        if (shipGrounded) {
            const distToShip = camera.position.distanceTo(shipModel.group.position);
            if (distToShip < 8) {
                shipHUD.showEnterPrompt();
            } else {
                shipHUD.hideEnterPrompt();
            }
        }

        // HUD
        const info = walker.getHUDInfo();
        const dnInfo = dayNightCycle.getHUDInfo();
        document.getElementById('altitudeValue').textContent =
            `${info.y}m`;
        document.getElementById('phaseInfo').textContent =
            `X:${info.x} Z:${info.z} · ${info.speed}m/s${info.isSprinting ? ' · SPRINT' : ''} · ${dnInfo.clock} ${dnInfo.phase}`;
    } else if (currentPhase === PHASE.FLIGHT || currentPhase === PHASE.GALAXY_MAP || currentPhase === PHASE.SYSTEM_VIEW) {
        // ---- FLIGHT / NAV PHASE ----
        // World keeps rolling even during galaxy map / system view
        // (the game is always online — the universe doesn't pause)

        if (currentPhase === PHASE.FLIGHT) {
            flightController.update(dt);
            flightController.getWorldPosition(_shipWorldPos);
        } else {
            // Ship parked — use last known position for world updates
            _shipWorldPos.copy(shipModel.group.position);
        }

        // --- World always updates (terrain, sky, water, life) ---
        terrainManager.update(_shipWorldPos, camera, dt);
        skyDome.update(_shipWorldPos, t);
        grassSystem.update(terrainManager.chunks, _shipWorldPos, t);
        rockScatter.update(terrainManager.chunks, _shipWorldPos);
        alienFlora.update(terrainManager.chunks, _shipWorldPos, t);
        terrainManager.updateWater(t, _shipWorldPos);
        atmosphericParticles.update(_shipWorldPos, t);
        groundFill.position.x = _shipWorldPos.x;
        groundFill.position.z = _shipWorldPos.z;

        // Day/night cycle — continues in flight
        dayNightCycle.update(dt);
        dayNightCycle.applyToScene({
            skyDome, sunLight, ambientLight, hemiLight,
            fillLight, rimLight, fog: scene.fog,
            atmospherePass, groundFillMat,
        });
        dayNightCycle.updateSunPosition(sunLight, _shipWorldPos);

        // --- Flight-specific systems (only when actively piloting) ---
        if (currentPhase === PHASE.FLIGHT) {
            weaponSystem.update(dt);
            scannerSystem.update(dt, _shipWorldPos);

            const flightInfo = flightController.getHUDInfo();
            hyperspaceSystem.update(dt, flightInfo.altitude);
            shipHUD.update(flightInfo, weaponSystem.getHUDInfo());

            document.getElementById('altitudeValue').textContent =
                `${flightInfo.altitude}m`;
            const dnInfo2 = dayNightCycle.getHUDInfo();
            document.getElementById('phaseInfo').textContent =
                `${flightInfo.speed}m/s · ${flightInfo.isBoosting ? 'BOOST' : 'CRUISE'} · ${dnInfo2.clock} ${dnInfo2.phase}`;
        }
    }

    // ---- Audio update (every frame) ----
    {
        const audioInfo = {};
        if (currentPhase === PHASE.FLIGHT) {
            const fi = flightController.getHUDInfo();
            audioInfo.speed = fi.speed;
            audioInfo.altitude = fi.altitude;
            const hi = hyperspaceSystem.getHUDInfo();
            audioInfo.isCharging = hi.isCharging;
            audioInfo.chargeProgress = hi.chargeProgress;
        } else if (currentPhase === PHASE.SURFACE) {
            const wi = walker.getHUDInfo();
            audioInfo.speed = wi.speed;
            audioManager.triggerFootstep(wi.speed);
        }
        audioManager.update(dt, audioInfo);
    }

    // Update film grain time uniform (animated noise pattern each frame)
    filmGrainPass.uniforms.uTime.value = t;

    // Render with full post-processing pipeline
    // (SSAO → Bloom → Color Grade → Film Grain → Output)
    composer.render();

    // Performance manager — adaptive quality
    perfManager.update(dt);

    // FPS
    frameCount++;
    if (t - lastFpsTime > 1) {
        const fps = Math.round(frameCount / (t - lastFpsTime));
        const stats = terrainManager.getStats();
        document.getElementById('perf').textContent =
            `${fps} FPS · ${perfManager.tierName} · ${stats.activeChunks} chunks (${stats.culledChunks || 0} culled) · LOD ${stats.lodBias?.toFixed(1) || '1.0'} · ${renderer.info.render.triangles} tris`;
        frameCount = 0;
        lastFpsTime = t;
    }
}

// ============================================================
// SAVE / LOAD — persist player's galactic position
// ============================================================
const SAVE_KEY = 'tgo_save';

function saveGame() {
    try {
        const saveData = {
            systemX: currentSystemX,
            systemY: currentSystemY,
            planetRule,
            planetSeed,
            timestamp: Date.now(),
        };
        localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
        console.log('[TGO] Game saved:', saveData);
    } catch (e) {
        console.warn('[TGO] Save failed:', e.message);
    }
}

function loadGame() {
    try {
        const raw = localStorage.getItem(SAVE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
    } catch (e) {
        console.warn('[TGO] Load failed:', e.message);
        return null;
    }
}

// Auto-load saved position if no URL params were provided
if (!params.has('rule') && !params.has('seed')) {
    const saved = loadGame();
    if (saved) {
        currentSystemX = saved.systemX;
        currentSystemY = saved.systemY;
        // Note: planetRule/planetSeed are already set from URL defaults;
        // the saved values match what was in the URL when saved
        console.log(`[TGO] Loaded save: System [${saved.systemX}, ${saved.systemY}]`);
    }
}

// Start!
animate();

// Debug access (expose to window for testing)
window._debug = {
    get scene() { return scene; },
    get camera() { return camera; },
    get npcManager() { return npcManager; },
    get walker() { return walker; },
    get terrain() { return terrainManager; },
    get dialogue() { return dialogue; },
    get tablet() { return tablet; },
    get encounterState() { return encounterState; },
    get ship() { return shipModel; },
    get flight() { return flightController; },
    get weapons() { return weaponSystem; },
    get scanner() { return scannerSystem; },
    get hyperspace() { return hyperspaceSystem; },
    get mining() { return miningSystem; },
    get inventory() { return inventory; },
    get perf() { return perfManager; },
    get phase() { return currentPhase; },
    get galaxyMap() { return galaxyMap; },
    get systemView() { return systemView; },
    get galacticPos() { return { x: currentSystemX, y: currentSystemY }; },
    get audio() { return audioManager; },
    get viewModel() { return fpsViewModel; },
    get dayNight() { return dayNightCycle; },
    get survival() { return survivalStats; },
    warpTo: transitionToPlanet,
};

</script>
</body>
</html>
